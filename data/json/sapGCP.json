{"name":"sap-gcp","title":"SAP Google Cloud Platform compliance profile","maintainer":"SAP Multi-Cloud Security","copyright":"SAP Multi-Cloud Security","copyright_email":"DL_5FA91E5D1DFE00027E55AD91@global.corp.sap","license":"Apache-2.0","summary":"SAP Google Cloud Platform compliance profile","version":"4.18.0","supports":[{"platform":"gcp"}],"depends":[{"name":"inspec-gcp","url":"https://github.com/inspec/inspec-gcp/archive/v1.10.0.tar.gz","status":"loaded"}],"inputs":[],"controls":[{"title":"2.1 - GCP User managed service account keys must be rotated within 90 days","desc":"Service Account are to be used by services, third-party tools or VM instances to execute commands or retrieve data via the google cloud API.\n    The service accounts often have access to resources through the API and therefore its authentication/access keys must be frequently rotated. Service accounts must have their keys rotated after 90 days.","descriptions":{"default":"Service Account are to be used by services, third-party tools or VM instances to execute commands or retrieve data via the google cloud API.\n    The service accounts often have access to resources through the API and therefore its authentication/access keys must be frequently rotated. Service accounts must have their keys rotated after 90 days."},"impact":0.8,"refs":[],"tags":{"sgs_wiki_url":"https://wiki.wdf.sap.corp/wiki/x/9Ik-cg","terraform_remediation":"  resource \"time_rotating\" \"example_time_rotating\" {\n    ...\n    rotation_days = <Value less than 90>\n  }\n\n  resource \"google_service_account_key\" \"example_google_service_account_key\" {\n    ...\n    keepers = {\n      rotation_time = time_rotating.example_time_rotating.rotation_rfc3339\n    }\n  }\n","tested_tf_version":"1.0.11","terraform_remediation_note":"Note this requires the terraform to be run regularly","remediation_steps":"  GCP service account keys dates can't be updated or fixed. In order to fix this alert, you'll need to delete the old key (which is older than 90 or more days) and then create a new key for that service account mentioned in the alert.\n\n  To create a new user managed service account key for a service account:\n\n  First, delete the user managed service account key that is older than 90 days:\n  1.  Login to GCP Portal > Go to APIs & Services by clicking on the 3 horizontal lines on the left side of the screen OR in the search bar, search for API & Services.\n  2.  Click Credentials.\n  3.  In the section for service accounts > click on the service account name the alert mentioned > click on the Keys tab.\n  4.  Click on the trash can icon.\n  5.  To create a new key, follow the steps below:\n\n  To create a new user managed service account key for a service account:\n  1.  Login to GCP Portal > Go to APIs & Services by clicking on the 3 horizontal lines on the left side of the screen OR in the search bar, search for API & Services.\n  2.  Click Credentials.\n  3.  Click Create Credentials > select Service Account Key.\n  4.  Choose the correct service account in a drop-down list.\n  5.  Select desired key type format among JSON or P12 > click on Create button (This will download the private key. Keep it in safe place).\n  6.  Click Close (if prompted).\n"},"code":"control '2_01_key_rotation' do\r\n  title '2.1 - GCP User managed service account keys must be rotated within 90 days'\r\n  impact 0.8\r\n  desc 'Service Account are to be used by services, third-party tools or VM instances to execute commands or retrieve data via the google cloud API.\r\n    The service accounts often have access to resources through the API and therefore its authentication/access keys must be frequently rotated. Service accounts must have their keys rotated after 90 days.'\r\n  tag sgs_wiki_url: 'https://wiki.wdf.sap.corp/wiki/x/9Ik-cg'\r\n  tag terraform_remediation: <<-EOF\r\n  resource \"time_rotating\" \"example_time_rotating\" {\r\n    ...\r\n    rotation_days = <Value less than 90>\r\n  }\r\n\r\n  resource \"google_service_account_key\" \"example_google_service_account_key\" {\r\n    ...\r\n    keepers = {\r\n      rotation_time = time_rotating.example_time_rotating.rotation_rfc3339\r\n    }\r\n  }\r\n  EOF\r\n  tag tested_tf_version: '1.0.11'\r\n  tag terraform_remediation_note: 'Note this requires the terraform to be run regularly'\r\n\r\n  tag remediation_steps: <<-EOF\r\n  GCP service account keys dates can't be updated or fixed. In order to fix this alert, you'll need to delete the old key (which is older than 90 or more days) and then create a new key for that service account mentioned in the alert.\r\n\r\n  To create a new user managed service account key for a service account:\r\n\r\n  First, delete the user managed service account key that is older than 90 days:\r\n  1.  Login to GCP Portal > Go to APIs & Services by clicking on the 3 horizontal lines on the left side of the screen OR in the search bar, search for API & Services.\r\n  2.  Click Credentials.\r\n  3.  In the section for service accounts > click on the service account name the alert mentioned > click on the Keys tab.\r\n  4.  Click on the trash can icon.\r\n  5.  To create a new key, follow the steps below:\r\n\r\n  To create a new user managed service account key for a service account:\r\n  1.  Login to GCP Portal > Go to APIs & Services by clicking on the 3 horizontal lines on the left side of the screen OR in the search bar, search for API & Services.\r\n  2.  Click Credentials.\r\n  3.  Click Create Credentials > select Service Account Key.\r\n  4.  Choose the correct service account in a drop-down list.\r\n  5.  Select desired key type format among JSON or P12 > click on Create button (This will download the private key. Keep it in safe place).\r\n  6.  Click Close (if prompted).\r\n  EOF\r\n\r\n  scan_date = ENV['MINERVA_SCHEDULED_SCAN_DATE'] ? Date.parse(ENV['MINERVA_SCHEDULED_SCAN_DATE']) : Date.today\r\n  google_service_accounts(project: gcp_project_id).service_account_names.each do |service_account|\r\n    service_account_name = service_account.split('/').last\r\n    google_service_account_keys(project: gcp_project_id, service_account: service_account_name).entries.each do |service_account_key|\r\n      next if service_account_key.key_type != 'USER_MANAGED'\r\n      created_date = Date.parse(service_account_key.valid_after_time.to_s)\r\n      describe \"Age of Service Account Key: #{service_account_key.key_name.split('/').last} under Service Account: #{service_account_name}\" do\r\n        subject { scan_date.mjd - created_date.mjd }\r\n        it { should be <= 90 }\r\n      end\r\n    end\r\n  end\r\nend\r\n","source_location":{"ref":"./controls/2_01.rb","line":3},"id":"2_01_key_rotation"},{"title":"2.1 - GCP IAM Users should not have overly permissive service account privileges","desc":"There are roles called \"iam.serviceAccountActor\" and \"roles/iam.serviceAccountAdmin\", which allows a user to obtain credentials for a service account and run operations as the service account. Nonservice accounts or end-users should not have the right to \"impersonate\" or act as a service account. Therefore, it should be ensured, that end-users or used access policies for users do not contain this role/permission.","descriptions":{"default":"There are roles called \"iam.serviceAccountActor\" and \"roles/iam.serviceAccountAdmin\", which allows a user to obtain credentials for a service account and run operations as the service account. Nonservice accounts or end-users should not have the right to \"impersonate\" or act as a service account. Therefore, it should be ensured, that end-users or used access policies for users do not contain this role/permission."},"impact":0.5,"refs":[],"tags":{"sgs_wiki_url":"https://wiki.wdf.sap.corp/wiki/x/9Ik-cg","terraform_remediation":"  resource \"google_project_iam_member\" \"example_google_project_iam_member\" {\n    role    = \"roles/iam.serviceAccountActor\"\n    member  = <Should not be structured like user:member@sap.com>\n  }\n\n  resource \"google_project_iam_member\" \"example_google_project_iam_member\" {\n    role    = \"roles/iam.serviceAccountAdmin\"\n    member  = <Should not be structured like user:member@sap.com>\n  }\n","tested_tf_version":"1.0.11","remediation_steps":"  1. Login to GCP console and type 'IAM & Admin' in the search bar > Click on the user account for which the alert is raised > Click on pencil icon which is Edit principal which you will find to the right of that row > Delete 'roles/iam.serviceAccountActor' and 'roles/iam.serviceAccountAdmin' roles for this user account.\n  2. Click on Save.\n"},"code":"control '2_01_overly_permissive_service_account_privileges' do\r\n  title '2.1 - GCP IAM Users should not have overly permissive service account privileges'\r\n  impact 0.5\r\n  desc 'There are roles called \"iam.serviceAccountActor\" and \"roles/iam.serviceAccountAdmin\", which allows a user to obtain credentials for a service account and run operations as the service account. Nonservice accounts or end-users should not have the right to \"impersonate\" or act as a service account. Therefore, it should be ensured, that end-users or used access policies for users do not contain this role/permission.'\r\n  tag sgs_wiki_url: 'https://wiki.wdf.sap.corp/wiki/x/9Ik-cg'\r\n  tag terraform_remediation: <<-EOF\r\n  resource \"google_project_iam_member\" \"example_google_project_iam_member\" {\r\n    role    = \"roles/iam.serviceAccountActor\"\r\n    member  = <Should not be structured like user:member@sap.com>\r\n  }\r\n\r\n  resource \"google_project_iam_member\" \"example_google_project_iam_member\" {\r\n    role    = \"roles/iam.serviceAccountAdmin\"\r\n    member  = <Should not be structured like user:member@sap.com>\r\n  }\r\n  EOF\r\n  tag tested_tf_version: '1.0.11'\r\n\r\n  tag remediation_steps: <<-EOF\r\n  1. Login to GCP console and type 'IAM & Admin' in the search bar > Click on the user account for which the alert is raised > Click on pencil icon which is Edit principal which you will find to the right of that row > Delete 'roles/iam.serviceAccountActor' and 'roles/iam.serviceAccountAdmin' roles for this user account.\r\n  2. Click on Save.\r\n  EOF\r\n\r\n  unless google_project_iam_binding(project: gcp_project_id, role: 'roles/iam.serviceAccountActor').members.nil?\r\n    google_project_iam_binding(project: gcp_project_id, role: 'roles/iam.serviceAccountActor').members.each do |member|\r\n      next if member.match?(/\\?uid=[\\d]+/) # This will skip the check for IAM users/service accounts that are deleted\r\n\r\n      describe \"IAM member #{member} attached to role roles/iam.serviceAccountActor principal type\" do\r\n        subject { member.split(':').first }\r\n        it { should_not cmp 'user' }\r\n      end\r\n    end\r\n  end\r\n\r\n  unless google_project_iam_binding(project: gcp_project_id, role: 'roles/iam.serviceAccountAdmin').members.nil?\r\n    google_project_iam_binding(project: gcp_project_id, role: 'roles/iam.serviceAccountAdmin').members.each do |member|\r\n      next if member.match?(/\\?uid=[\\d]+/) # This will skip the check for IAM users/service accounts that are deleted\r\n\r\n      describe \"IAM member #{member} attached to role roles/iam.serviceAccountAdmin principal type\" do\r\n        subject { member.split(':').first }\r\n        it { should_not cmp 'user' }\r\n      end\r\n    end\r\n  end\r\nend\r\n","source_location":{"ref":"./controls/2_01.rb","line":60},"id":"2_01_overly_permissive_service_account_privileges"},{"title":"2.1 - GCP IAM user should not be permitted to use service account privileges","desc":"GCP IAM users should not be permitted to use Service account privileges. Service account privileges allow services gain access to processes through API connections.\n    Therefore, the roles assigned to IAM users should not include any service account privileged role in order to prevent privilege escalation through a user account.","descriptions":{"default":"GCP IAM users should not be permitted to use Service account privileges. Service account privileges allow services gain access to processes through API connections.\n    Therefore, the roles assigned to IAM users should not include any service account privileged role in order to prevent privilege escalation through a user account."},"impact":0.5,"refs":[],"tags":{"sgs_wiki_url":"https://wiki.wdf.sap.corp/wiki/x/9Ik-cg","terraform_remediation":"\n  resource \"google_project_iam_member\" \"example_google_project_iam_member\" {\n    role    = \"roles/iam.serviceAccountUser\"\n    member  = <Should start with \"serviceAccount:\">\n  }\n\n  resource \"google_project_iam_member\" \"example_google_project_iam_member\" {\n    role    = \"roles/iam.serviceAccountTokenCreator\"\n    member  = <Should start with \"serviceAccount:\">\n  }\n","tested_tf_version":"1.0.11","remediation_steps":"  1.  Login to GCP console and type 'IAM & Admin' in the search bar > Click on the user account for which the alert is raised > Click on pencil icon which is Edit principal which you will find to the right of that row > Delete 'roles/iam.serviceAccountActor', 'roles/iam.serviceAccountUser' and 'roles/iam.serviceAccountTokenCreator' roles for this user account.\n  2.  Click Save.\n"},"code":"control '2_01_iam_user_with_service_account_privileges' do\r\n  title '2.1 - GCP IAM user should not be permitted to use service account privileges'\r\n  impact 0.5\r\n  desc 'GCP IAM users should not be permitted to use Service account privileges. Service account privileges allow services gain access to processes through API connections.\r\n    Therefore, the roles assigned to IAM users should not include any service account privileged role in order to prevent privilege escalation through a user account.'\r\n  tag sgs_wiki_url: 'https://wiki.wdf.sap.corp/wiki/x/9Ik-cg'\r\n  tag terraform_remediation: <<-EOF\r\n\r\n  resource \"google_project_iam_member\" \"example_google_project_iam_member\" {\r\n    role    = \"roles/iam.serviceAccountUser\"\r\n    member  = <Should start with \"serviceAccount:\">\r\n  }\r\n\r\n  resource \"google_project_iam_member\" \"example_google_project_iam_member\" {\r\n    role    = \"roles/iam.serviceAccountTokenCreator\"\r\n    member  = <Should start with \"serviceAccount:\">\r\n  }\r\n  EOF\r\n  tag tested_tf_version: '1.0.11'\r\n\r\n  tag remediation_steps: <<-EOF\r\n  1.  Login to GCP console and type 'IAM & Admin' in the search bar > Click on the user account for which the alert is raised > Click on pencil icon which is Edit principal which you will find to the right of that row > Delete 'roles/iam.serviceAccountActor', 'roles/iam.serviceAccountUser' and 'roles/iam.serviceAccountTokenCreator' roles for this user account.\r\n  2.  Click Save.\r\n  EOF\r\n\r\n  unless google_project_iam_binding(project: gcp_project_id, role: 'roles/iam.serviceAccountUser').members.nil?\r\n    google_project_iam_binding(project: gcp_project_id, role: 'roles/iam.serviceAccountUser').members.each do |member|\r\n      next if member.match?(/\\?uid=[\\d]+/) # This will skip the check for IAM users/service accounts that are deleted\r\n\r\n      describe \"IAM member #{member} attached to role roles/iam.serviceAccountUser principal type\" do\r\n        subject { member.split(':').first }\r\n        it { should_not cmp 'user' }\r\n      end\r\n    end\r\n  end\r\n\r\n  unless google_project_iam_binding(project: gcp_project_id, role: 'roles/iam.serviceAccountTokenCreator').members.nil?\r\n    google_project_iam_binding(project: gcp_project_id, role: 'roles/iam.serviceAccountTokenCreator').members.each do |member|\r\n      next if member.match?(/\\?uid=[\\d]+/) # This will skip the check for IAM users/service accounts that are deleted\r\n\r\n      describe \"IAM member #{member} attached to role roles/iam.serviceAccountTokenCreator principal type\" do\r\n        subject { member.split(':').first }\r\n        it { should_not cmp 'user' }\r\n      end\r\n    end\r\n  end\r\nend\r\n","source_location":{"ref":"./controls/2_01.rb","line":106},"id":"2_01_iam_user_with_service_account_privileges"},{"title":"2.2 - GCP non-corporate accounts must not have access to GCP resources as owner/editor","desc":"SAP non-corporate accounts must not have access to GCP resources as owner/editor. IAM roles for SAP non-corporate accounts must not contain roles/owner or roles/editor","descriptions":{"default":"SAP non-corporate accounts must not have access to GCP resources as owner/editor. IAM roles for SAP non-corporate accounts must not contain roles/owner or roles/editor"},"impact":0.8,"refs":[],"tags":{"sgs_wiki_url":"https://wiki.wdf.sap.corp/wiki/x/9Ik-cg","terraform_remediation":"  resource \"google_project_iam_binding\" \"example_google_project_iam_binding\" {\n    ...\n    role   =  \"roles/editor\"\n    members = [\n     <must only be GCP corporate accounts>\n    ]\n  }\n\n  resource \"google_project_iam_binding\" \"example_google_project_iam_binding\" {\n    ...\n    role   =  \"roles/owner\"\n    members = [\n      <must only be GCP corporate accounts>\n    ]\n  }\n","tested_tf_version":"1.0.11","terraform_remediation_note":"GCP corporate accounts are those only ending in either @sap.com, gserviceaccount.com, sap.com@gtempaccount.com, or multicloud.int.sap","remediation_steps":"  It's highly recommended to utilize our managed corporate google accounts. Using our managed corporate accounts allows for bolstered visibility, auditing, accountability and control over access to our Google Cloud Platform resources. Do not access GCP resources through your personal accounts.\n"},"code":"control '2_02_non_corporate_accounts' do\r\n  title '2.2 - GCP non-corporate accounts must not have access to GCP resources as owner/editor'\r\n  impact 0.8\r\n  desc 'SAP non-corporate accounts must not have access to GCP resources as owner/editor. IAM roles for SAP non-corporate accounts must not contain roles/owner or roles/editor'\r\n  tag sgs_wiki_url: 'https://wiki.wdf.sap.corp/wiki/x/9Ik-cg'\r\n  tag terraform_remediation: <<-EOF\r\n  resource \"google_project_iam_binding\" \"example_google_project_iam_binding\" {\r\n    ...\r\n    role   =  \"roles/editor\"\r\n    members = [\r\n     <must only be GCP corporate accounts>\r\n    ]\r\n  }\r\n\r\n  resource \"google_project_iam_binding\" \"example_google_project_iam_binding\" {\r\n    ...\r\n    role   =  \"roles/owner\"\r\n    members = [\r\n      <must only be GCP corporate accounts>\r\n    ]\r\n  }\r\n  EOF\r\n  tag tested_tf_version: '1.0.11'\r\n  tag terraform_remediation_note: 'GCP corporate accounts are those only ending in either @sap.com, gserviceaccount.com, sap.com@gtempaccount.com, or multicloud.int.sap'\r\n\r\n  tag remediation_steps: <<-EOF\r\n  It's highly recommended to utilize our managed corporate google accounts. Using our managed corporate accounts allows for bolstered visibility, auditing, accountability and control over access to our Google Cloud Platform resources. Do not access GCP resources through your personal accounts.\r\n  EOF\r\n\r\n  next if google_project_iam_binding(project: gcp_project_id, role: 'roles/editor').members.nil? == true\r\n  google_project_iam_binding(project: gcp_project_id, role: 'roles/editor').members.each do |member|\r\n    next if member.match?(/\\?uid=[\\d]+/) # This will skip the check for IAM users/service accounts that are deleted\r\n\r\n    describe \"Domain for #{member.split('@').first} with editor role\" do\r\n      subject { member.split('@').last }\r\n      it { should cmp /sap.com|emarsys.com|gserviceaccount.com|sap.com@gtempaccount.com|multicloud.int.sap|loyalsys.io/ }\r\n    end\r\n  end\r\n\r\n  next if google_project_iam_binding(project: gcp_project_id, role: 'roles/owner').members.nil? == true\r\n  google_project_iam_binding(project: gcp_project_id, role: 'roles/owner').members.each do |member|\r\n    next if member.match?(/\\?uid=[\\d]+/) # This will skip the check for IAM users/service accounts that are deleted\r\n\r\n    describe \"Domain for #{member.split('@').first} with owner role\" do\r\n      subject { member.split('@').last }\r\n      it { should cmp /sap.com|emarsys.com|gserviceaccount.com|sap.com@gtempaccount.com|multicloud.int.sap|loyalsys.io/ }\r\n    end\r\n  end\r\nend\r\n","source_location":{"ref":"./controls/2_02.rb","line":3},"id":"2_02_non_corporate_accounts"},{"title":"2.3 - MFA must be enabled for all users in GCP projects","desc":"Enforce MFA for all accounts","descriptions":{"default":"Enforce MFA for all accounts"},"impact":0.8,"refs":[],"tags":{"sgs_control_hash":"8ae223887226fcbd01722703b9830087","sgs_wiki_url":"https://wiki.wdf.sap.corp/wiki/x/9Ik-cg"},"code":"control '2_03_mfa_enforced' do\r\n  impact 0.8\r\n  title '2.3 - MFA must be enabled for all users in GCP projects'\r\n  desc 'Enforce MFA for all accounts'\r\n  tag sgs_control_hash: '8ae223887226fcbd01722703b9830087'\r\n  tag sgs_wiki_url: 'https://wiki.wdf.sap.corp/wiki/x/9Ik-cg'\r\n\r\n  google_users(project: gcp_project_id).user_ids.each do |user_id|\r\n    describe google_user(user_key: user_id) do\r\n      it { should have_mfa_enabled }\r\n    end\r\n  end\r\nend\r\n","source_location":{"ref":"./controls/3_01-and-2_03.rb","line":3},"id":"2_03_mfa_enforced"},{"title":"3.2 and 3.3 - GCP Cloud Audit logs must be enabled for Google Cloud SQL and Google Cloud Storage","desc":"It must be ensured that Cloud Audit logs are set up to have the Data Read and Data Write log types for Google Cloud Storage and Google Cloud SQL.","descriptions":{"default":"It must be ensured that Cloud Audit logs are set up to have the Data Read and Data Write log types for Google Cloud Storage and Google Cloud SQL."},"impact":0.8,"refs":[],"tags":{"sgs_control_hash":"8ae223887226fcbd01722703b9830012","cis":"gcp:2.1","level":1,"sgs_wiki_url":"https://wiki.wdf.sap.corp/wiki/x/9Ik-cg","remediation_steps":"    1.  Login to GCP console and navigate to IAM & Admin > click on Audit Logs.\n    2.  Click on the relevant service that you need to enable logging for (either Google Cloud Storage or Cloud SQL, or select Default Audit Config at the top.)\n    3.  In the Log Type tab > select the check boxes for Data Read and Data Write > Click Save.\n    4.  In the Exempted Users tab, remove all users (if any) > Click Save.\n","terraform_remediation":"    resource \"google_project_iam_audit_config\" \"example_audit_logging\" {\n        project = <your project id>\n        service = <cloudsql.googleapis.com or storage.googleapis.com or allServices>\n        audit_log_config {\n          log_type = 'DATA_WRITE'\n        }\n        audit_log_config {\n          log_type = 'DATA_READ'\n        }\n      }\n","tested_tf_version":"1.0.11"},"code":"control '3_02_and_3_03_audit_log_enabled' do\r\n  impact 0.8\r\n  title '3.2 and 3.3 - GCP Cloud Audit logs must be enabled for Google Cloud SQL and Google Cloud Storage'\r\n  desc 'It must be ensured that Cloud Audit logs are set up to have the Data Read and Data Write log types for Google Cloud Storage and Google Cloud SQL.'\r\n\r\n  tag sgs_control_hash: '8ae223887226fcbd01722703b9830012'\r\n  tag cis: 'gcp:2.1'\r\n  tag level: 1\r\n  tag sgs_wiki_url: 'https://wiki.wdf.sap.corp/wiki/x/9Ik-cg'\r\n  tag remediation_steps: <<-EOF\r\n    1.  Login to GCP console and navigate to IAM & Admin > click on Audit Logs.\r\n    2.  Click on the relevant service that you need to enable logging for (either Google Cloud Storage or Cloud SQL, or select Default Audit Config at the top.)\r\n    3.  In the Log Type tab > select the check boxes for Data Read and Data Write > Click Save.\r\n    4.  In the Exempted Users tab, remove all users (if any) > Click Save.\r\n    EOF\r\n  tag terraform_remediation: <<-EOF\r\n    resource \"google_project_iam_audit_config\" \"example_audit_logging\" {\r\n        project = <your project id>\r\n        service = <cloudsql.googleapis.com or storage.googleapis.com or allServices>\r\n        audit_log_config {\r\n          log_type = 'DATA_WRITE'\r\n        }\r\n        audit_log_config {\r\n          log_type = 'DATA_READ'\r\n        }\r\n      }\r\n    EOF\r\n  tag tested_tf_version: '1.0.11'\r\n\r\n  services = []\r\n\r\n  # Audit log settings of services are checked only if the services are used\r\n  if google_sql_database_instances(project: gcp_project_id).count > 0\r\n    services << 'cloudsql.googleapis.com'\r\n  end\r\n\r\n  if google_storage_buckets(project: gcp_project_id).count > 0\r\n    services << 'storage.googleapis.com'\r\n  end\r\n\r\n  iam_policy = google_project_iam_policy(project: gcp_project_id)\r\n\r\n  # ensure that audit_configs exists and is an array\r\n  audit_configs = iam_policy.audit_configs || []\r\n\r\n  services.each do |service|\r\n    log_types = []\r\n\r\n    audit_configs.each do |audit_config|\r\n      next unless audit_config.service == service || audit_config.service == 'allServices'\r\n\r\n      log_types += audit_config.audit_log_configs.map(&:log_type)\r\n    end\r\n\r\n    describe \"Audit logging for #{service}\" do\r\n      subject { log_types }\r\n      it { should include 'DATA_WRITE' }\r\n      it { should include 'DATA_READ' }\r\n    end\r\n  end\r\nend\r\n","source_location":{"ref":"./controls/3_02-and-3_03.rb","line":3},"id":"3_02_and_3_03_audit_log_enabled"},{"title":"3.6 - GCP IAM user should not have overly permissive Cloud KMS roles","desc":"This policy identifies IAM users who have overly permissive Cloud KMS roles.\n  Built-in/Predefined IAM role Cloud KMS Admin allows the user to create, delete, and manage service accounts.\n  Built-in/Predefined IAM role Cloud KMS CryptoKey Encrypter/Decrypter allows the user to encrypt and decrypt data at rest using the encryption keys.\n  It is recommended to follow the principle of Separation of Duties ensuring that one individual does not have all the necessary permissions\n  to be able to complete a malicious action.","descriptions":{"default":"This policy identifies IAM users who have overly permissive Cloud KMS roles.\n  Built-in/Predefined IAM role Cloud KMS Admin allows the user to create, delete, and manage service accounts.\n  Built-in/Predefined IAM role Cloud KMS CryptoKey Encrypter/Decrypter allows the user to encrypt and decrypt data at rest using the encryption keys.\n  It is recommended to follow the principle of Separation of Duties ensuring that one individual does not have all the necessary permissions\n  to be able to complete a malicious action."},"impact":0.5,"refs":[],"tags":{"sgs_wiki_url":"https://wiki.wdf.sap.corp/wiki/x/9Ik-cg","terraform_remediation":"  resource \"google_project_iam_binding\" \"example_google_project_iam_binding\" {\n    ...\n    role    = 'roles/cloudkms.admin'\n    members = [\n    ]\n  }\n\n  resource \"google_project_iam_binding\" \"example_google_project_iam_binding\" {\n    ...\n    role    = 'roles/cloudkms.cryptoKeyEncrypterDecrypter'\n    members = [\n    ]\n  }\n","tested_tf_version":"1.0.11","terraform_remediation_note":"Neither KMS admin nor KMS cryptokeyEncrypterDecrypter should be assigned to any project members, and the above terraform will remove any members from these roles.","remediation_steps":"  1.  Login to GCP console and type IAM & Admin in the search bar > Click on the account for which the alert is raised > Click on pencil icon which is Edit principal which you will find to the right of that row > Delete 'roles/cloudkms.admin' and 'roles/cloudkms.cryptoKeyEncrypterDecrypter' roles for this account.\n  2.  Click Save.\n"},"code":"control '3_06_iam_user_with_overly_permissive_kms_roles' do\r\n  title '3.6 - GCP IAM user should not have overly permissive Cloud KMS roles'\r\n  impact 0.5\r\n  desc 'This policy identifies IAM users who have overly permissive Cloud KMS roles.\r\n  Built-in/Predefined IAM role Cloud KMS Admin allows the user to create, delete, and manage service accounts.\r\n  Built-in/Predefined IAM role Cloud KMS CryptoKey Encrypter/Decrypter allows the user to encrypt and decrypt data at rest using the encryption keys.\r\n  It is recommended to follow the principle of Separation of Duties ensuring that one individual does not have all the necessary permissions\r\n  to be able to complete a malicious action.'\r\n  tag sgs_wiki_url: 'https://wiki.wdf.sap.corp/wiki/x/9Ik-cg'\r\n  tag terraform_remediation: <<-EOF\r\n  resource \"google_project_iam_binding\" \"example_google_project_iam_binding\" {\r\n    ...\r\n    role    = 'roles/cloudkms.admin'\r\n    members = [\r\n    ]\r\n  }\r\n\r\n  resource \"google_project_iam_binding\" \"example_google_project_iam_binding\" {\r\n    ...\r\n    role    = 'roles/cloudkms.cryptoKeyEncrypterDecrypter'\r\n    members = [\r\n    ]\r\n  }\r\n  EOF\r\n  tag tested_tf_version: '1.0.11'\r\n  tag terraform_remediation_note: 'Neither KMS admin nor KMS cryptokeyEncrypterDecrypter should be assigned to any project members, and the above terraform will remove any members from these roles.'\r\n\r\n  tag remediation_steps: <<-EOF\r\n  1.  Login to GCP console and type IAM & Admin in the search bar > Click on the account for which the alert is raised > Click on pencil icon which is Edit principal which you will find to the right of that row > Delete 'roles/cloudkms.admin' and 'roles/cloudkms.cryptoKeyEncrypterDecrypter' roles for this account.\r\n  2.  Click Save.\r\n  EOF\r\n\r\n  describe google_project_iam_binding(project: gcp_project_id, role: 'roles/cloudkms.admin') do\r\n    its('members') { should be_nil }\r\n  end\r\n\r\n  describe google_project_iam_binding(project: gcp_project_id, role: 'roles/cloudkms.cryptoKeyEncrypterDecrypter') do\r\n    its('members') { should be_nil }\r\n  end\r\nend\r\n","source_location":{"ref":"./controls/3_06.rb","line":3},"id":"3_06_iam_user_with_overly_permissive_kms_roles"},{"title":"3.6 - Google Cloud Key Management System (KMS) must be configured securely","desc":"The Google Cloud Key Management Service (KMS) must be used for key management in the GCP project. It\nis a cloud-hosted key management service that lets you manage cryptographic keys for your cloud services\nthe same way you do on premises. Cloud KMS is integrated with Cloud IAM and Cloud Audit Logging so that\nyou can manage permissions on individual keys and monitor how these are used.","descriptions":{"default":"The Google Cloud Key Management Service (KMS) must be used for key management in the GCP project. It\nis a cloud-hosted key management service that lets you manage cryptographic keys for your cloud services\nthe same way you do on premises. Cloud KMS is integrated with Cloud IAM and Cloud Audit Logging so that\nyou can manage permissions on individual keys and monitor how these are used."},"impact":0.8,"refs":[],"tags":{"sgs_control_hash":"8ae223887226fcbd01722703b9830048","sgs_wiki_url":"https://wiki.wdf.sap.corp/wiki/x/9Ik-cg","terraform_remediation":"  resource \"google_kms_crypto_key\" \"example_google_kms_key\" {\n    ...\n    rotation_period = <Valid rotation period>\n    ...\n  }\n","tested_tf_version":"1.0.11","terraform_remediation_note":"The rotation period has the format of a decimal number with up to 9 fractional digits, followed by the letter s (seconds). It must be greater than a day (ie, 86400).","remediation_steps":"  1.  Sign in to GCP Portal.\n  2.  Navigate to Cloud Key Management Service (KMS) dashboard (or search for KMS in the search bar) > click on the name of the GCP KMS key ring that you need to change\n  3.  Click on the key submenu icon (3 dots) available on the right side of the key name >  choose edit rotation period.\n  4.  In the Edit rotation period configuration box > select an optimal rotation period of less than 90 days for the selected key(After this time frame, a new KMS key version will be created and used to encrypt new data. Use the Starting on date picker (DTP) to set up the starting day for the set rotation period, which is recommended to be as soon as possible) > click Save.\n"},"code":"control '3_06_secure_kms_usage' do\r\n  impact 0.8\r\n  title '3.6 - Google Cloud Key Management System (KMS) must be configured securely'\r\n  desc '\r\n  The Google Cloud Key Management Service (KMS) must be used for key management in the GCP project. It\r\n  is a cloud-hosted key management service that lets you manage cryptographic keys for your cloud services\r\n  the same way you do on premises. Cloud KMS is integrated with Cloud IAM and Cloud Audit Logging so that\r\n  you can manage permissions on individual keys and monitor how these are used.'\r\n  tag sgs_control_hash: '8ae223887226fcbd01722703b9830048'\r\n  tag sgs_wiki_url: 'https://wiki.wdf.sap.corp/wiki/x/9Ik-cg'\r\n  tag terraform_remediation: <<-EOF\r\n  resource \"google_kms_crypto_key\" \"example_google_kms_key\" {\r\n    ...\r\n    rotation_period = <Valid rotation period>\r\n    ...\r\n  }\r\n  EOF\r\n  tag tested_tf_version: '1.0.11'\r\n  tag terraform_remediation_note: 'The rotation period has the format of a decimal number with up to 9 fractional digits, followed by the letter s (seconds). It must be greater than a day (ie, 86400).'\r\n\r\n  tag remediation_steps: <<-EOF\r\n  1.  Sign in to GCP Portal.\r\n  2.  Navigate to Cloud Key Management Service (KMS) dashboard (or search for KMS in the search bar) > click on the name of the GCP KMS key ring that you need to change\r\n  3.  Click on the key submenu icon (3 dots) available on the right side of the key name >  choose edit rotation period.\r\n  4.  In the Edit rotation period configuration box > select an optimal rotation period of less than 90 days for the selected key(After this time frame, a new KMS key version will be created and used to encrypt new data. Use the Starting on date picker (DTP) to set up the starting day for the set rotation period, which is recommended to be as soon as possible) > click Save.\r\n  EOF\r\n\r\n  google_compute_regions(project: gcp_project_id).region_names.push('global').each do |region_name|\r\n    google_kms_key_rings(project: gcp_project_id, location: region_name).key_ring_names.each do |key_ring_name|\r\n      google_kms_crypto_keys(project: gcp_project_id, location: region_name, key_ring_name: key_ring_name).table.entries.each do |crypto_key|\r\n        next if crypto_key[:primary].nil?\r\n        next if crypto_key[:primary]['primary']['state'] == 'DESTROYED'\r\n        next if crypto_key[:primary]['primary']['state'] == 'DESTROY_SCHEDULED'\r\n        next if crypto_key[:primary]['primary']['state'] == 'DISABLED'\r\n\r\n        describe \"rotation period for crypto key #{crypto_key[:crypto_key_name]} attached to key ring #{key_ring_name}\" do\r\n          subject { crypto_key[:rotation_period] }\r\n          it { should_not eq nil }\r\n        end\r\n      end\r\n    end\r\n  end\r\nend\r\n","source_location":{"ref":"./controls/3_06.rb","line":44},"id":"3_06_secure_kms_usage"},{"title":"4.5 - GCP VM instances must have Block project-wide SSH keys activated","desc":"All VM instances that do not depend on the usage of such GCP project wide OS access keys MUST activate the \"Block project-wide public SSH keys\" in the meta data configuration of the VM instance.","descriptions":{"default":"All VM instances that do not depend on the usage of such GCP project wide OS access keys MUST activate the \"Block project-wide public SSH keys\" in the meta data configuration of the VM instance."},"impact":0.8,"refs":[],"tags":{"sgs_wiki_url":"https://wiki.wdf.sap.corp/wiki/x/9Ik-cg","terraform_remediation":"  resource \"google_compute_instance\" \"example_compute_instance\" {\n    ...\n    metadata = {\n        block-project-ssh-keys = true\n    }\n  }\n  If a node pool is configured for GKE cluster, this needs to be enabled for those compute instances as well:\n  resource \"google_container_node_pool\" \"example_node_pool\" {\n    ...\n    node_config {\n      ...\n      metadata = {\n        block-project-ssh-keys = true\n      }\n    }\n  }\n","tested_tf_version":"1.0.11","remediation_steps":"  1. Login to GCP console and type Compute Engine in the search bar > Click on the instance for which the alert is raised.\n  2. Click EDIT > Scroll down under 'Security and access' section > 'SSH Key's sub-section > 'Block project-wide SSH keys' checkbox should be checked.\n"},"code":"control '4_05_compute_instance_block_ssh_keys' do\r\n  title '4.5 - GCP VM instances must have Block project-wide SSH keys activated'\r\n  impact 0.8\r\n  desc 'All VM instances that do not depend on the usage of such GCP project wide OS access keys MUST activate the \"Block project-wide public SSH keys\" in the meta data configuration of the VM instance.'\r\n  tag sgs_wiki_url: 'https://wiki.wdf.sap.corp/wiki/x/9Ik-cg'\r\n  tag terraform_remediation: <<-EOF\r\n  resource \"google_compute_instance\" \"example_compute_instance\" {\r\n    ...\r\n    metadata = {\r\n        block-project-ssh-keys = true\r\n    }\r\n  }\r\n  If a node pool is configured for GKE cluster, this needs to be enabled for those compute instances as well:\r\n  resource \"google_container_node_pool\" \"example_node_pool\" {\r\n    ...\r\n    node_config {\r\n      ...\r\n      metadata = {\r\n        block-project-ssh-keys = true\r\n      }\r\n    }\r\n  }\r\n  EOF\r\n  tag tested_tf_version: '1.0.11'\r\n\r\n  tag remediation_steps: <<-EOF\r\n  1. Login to GCP console and type Compute Engine in the search bar > Click on the instance for which the alert is raised.\r\n  2. Click EDIT > Scroll down under 'Security and access' section > 'SSH Key's sub-section > 'Block project-wide SSH keys' checkbox should be checked.\r\n  EOF\r\n\r\n  google_compute_zones(project: gcp_project_id).zone_names.each do |zone_name|\r\n    google_compute_instances(project: gcp_project_id, zone: zone_name).entries.each do |compute_instance|\r\n      next if compute_instance.instance_name.match?(/^shoot--/)\r\n\r\n      if compute_instance.metadata['items'].nil?\r\n        describe \"Metadata for #{compute_instance.instance_name} should be configured and hence it\" do\r\n          subject { compute_instance.metadata['items'] }\r\n          it { should_not be_nil }\r\n        end\r\n      else\r\n        describe \"Block project SSH keys for #{compute_instance.instance_name}\" do\r\n          subject { compute_instance.metadata['items'].to_s.match?(/{\\\"key\\\"=>\\\"block-project-ssh-keys\\\", \\\"value\\\"=>\\\"true\\\"}/i) }\r\n          it { should eq true }\r\n        end\r\n      end\r\n    end\r\n  end\r\nend\r\n","source_location":{"ref":"./controls/4_05.rb","line":3},"id":"4_05_compute_instance_block_ssh_keys"},{"title":"5.1 - GCP Storage buckets must not be publicly accessible to all users","desc":"Public buckets access for all Users are per default not allowed","descriptions":{"default":"Public buckets access for all Users are per default not allowed"},"impact":0.8,"refs":[],"tags":{"sgs_control_hash":"8ae223887226fcbd01722703b9830036","cis":"gcp:5.1","level":1,"sgs_wiki_url":"https://wiki.wdf.sap.corp/wiki/x/9Ik-cg","terraform_remediation":"  resource \"google_storage_bucket_access_control\" \"example_google_storage_bucket_access_control\" {\n    ...\n    role   =  <Some bucket role>\n    entity =  <Should not be equal to \"allUsers\">\n  }\n","tested_tf_version":"1.0.11","remediation_steps":"  1.  Login to GCP console and type 'Cloud Storage' in the search bar > Click on the bucket for which the alert is raised.\n  2. b Click on 'PERMISSIONS' tab > Under 'Public access' > Click on 'PREVENT PUBLIC ACCESS' > Click Confirm.\n"},"code":"control '5_01_public_buckets_all_users_restricted' do\r\n  impact 0.8\r\n  title '5.1 - GCP Storage buckets must not be publicly accessible to all users'\r\n  desc 'Public buckets access for all Users are per default not allowed'\r\n  tag sgs_control_hash: '8ae223887226fcbd01722703b9830036'\r\n  tag cis: 'gcp:5.1'\r\n  tag level: 1\r\n  tag sgs_wiki_url: 'https://wiki.wdf.sap.corp/wiki/x/9Ik-cg'\r\n  tag terraform_remediation: <<-EOF\r\n  resource \"google_storage_bucket_access_control\" \"example_google_storage_bucket_access_control\" {\r\n    ...\r\n    role   =  <Some bucket role>\r\n    entity =  <Should not be equal to \"allUsers\">\r\n  }\r\n  EOF\r\n  tag tested_tf_version: '1.0.11'\r\n  tag remediation_steps: <<-EOF\r\n  1.  Login to GCP console and type 'Cloud Storage' in the search bar > Click on the bucket for which the alert is raised.\r\n  2. b Click on 'PERMISSIONS' tab > Under 'Public access' > Click on 'PREVENT PUBLIC ACCESS' > Click Confirm.\r\n  EOF\r\n  google_storage_buckets(project: gcp_project_id).bucket_names.each do |bucket_name|\r\n    bucket = google_storage_bucket(name: bucket_name)\r\n    next if bucket.labels.nil? == false && bucket.labels.select { |key, value| key == 'sec-by-def-public-storage-exception' && value == 'enabled' }.empty? == false\r\n    iam_policy = google_storage_bucket_iam_policy(bucket: bucket_name)\r\n    next if iam_policy.bindings.nil? == true\r\n    iam_policy.bindings.each_with_index do |binding, i|\r\n      # To reduce control output, select elements that match allUsers from members array\r\n      # and expect that the count of the resulting array is zero\r\n      describe \"Bucket IamPolicy #{bucket_name} IamPolicyBindings[#{i}] members allUsers\" do\r\n        subject { binding.members.select { |b| b.match(/allUsers/) } }\r\n        its('count') { should eq 0 }\r\n      end\r\n    end\r\n  end\r\nend\r\n","source_location":{"ref":"./controls/5_01.rb","line":2},"id":"5_01_public_buckets_all_users_restricted"},{"title":"5.1 - GCP Storage buckets must not be publicly accessible to all authenticated users","desc":"Public buckets access for All Authenticated users are per default not allowed","descriptions":{"default":"Public buckets access for All Authenticated users are per default not allowed"},"impact":0.8,"refs":[],"tags":{"sgs_control_hash":"8ae223887226fcbd01722703b9830036","cis":"gcp:5.1","level":1,"sgs_wiki_url":"https://wiki.wdf.sap.corp/wiki/x/9Ik-cg","terraform_remediation":"  resource \"google_storage_bucket_access_control\" \"example_google_storage_bucket_access_control\" {\n    ...\n    role   =  <Some bucket role>\n    entity =  <must not be equal to \"allAuthenticatedUsers\">\n  }\n","tested_tf_version":"1.0.11","remediation_steps":"  1.  Login to GCP console and type 'Cloud Storage' in the search bar > Click on the bucket for which the alert is raised.\n  2.  Click on 'PERMISSIONS' tab > Under 'Public access' > Click on 'PREVENT PUBLIC ACCESS' > Click Confirm.\n"},"code":"control '5_01_public_buckets_all_authenticated_users_restricted' do\r\n  impact 0.8\r\n  title '5.1 - GCP Storage buckets must not be publicly accessible to all authenticated users'\r\n  desc 'Public buckets access for All Authenticated users are per default not allowed'\r\n  tag sgs_control_hash: '8ae223887226fcbd01722703b9830036'\r\n  tag cis: 'gcp:5.1'\r\n  tag level: 1\r\n  tag sgs_wiki_url: 'https://wiki.wdf.sap.corp/wiki/x/9Ik-cg'\r\n  tag terraform_remediation: <<-EOF\r\n  resource \"google_storage_bucket_access_control\" \"example_google_storage_bucket_access_control\" {\r\n    ...\r\n    role   =  <Some bucket role>\r\n    entity =  <must not be equal to \"allAuthenticatedUsers\">\r\n  }\r\n  EOF\r\n  tag tested_tf_version: '1.0.11'\r\n\r\n  tag remediation_steps: <<-EOF\r\n  1.  Login to GCP console and type 'Cloud Storage' in the search bar > Click on the bucket for which the alert is raised.\r\n  2.  Click on 'PERMISSIONS' tab > Under 'Public access' > Click on 'PREVENT PUBLIC ACCESS' > Click Confirm.\r\n  EOF\r\n\r\n  google_storage_buckets(project: gcp_project_id).bucket_names.each do |bucket_name|\r\n    iam_policy = google_storage_bucket_iam_policy(bucket: bucket_name)\r\n    next if iam_policy.bindings.nil? == true\r\n\r\n    iam_policy.bindings.each_with_index do |binding, i|\r\n      # To reduce control output, select elements that match allAuthenticatedUsers from members array\r\n      # and expect that the count of the resulting array is zero\r\n      describe \"Bucket IamPolicy #{bucket_name} IamPolicyBindings[#{i}] members allAuthenticatedUsers\" do\r\n        subject { binding.members.select { |b| b.match(/allAuthenticatedUsers/) } }\r\n        its('count') { should eq 0 }\r\n      end\r\n    end\r\n  end\r\nend\r\n","source_location":{"ref":"./controls/5_01.rb","line":38},"id":"5_01_public_buckets_all_authenticated_users_restricted"},{"title":"5.1 - GCP Storage buckets must have Uniform access control enabled","desc":"To prevent public access on Google Cloud Storage objects, permissions must be configured at bucket level and not on object level. Hence, the accessibility must be configured on a bucket level to be uniform. It is advised to use bucket level policies, because ACLs are a legacy access control system.","descriptions":{"default":"To prevent public access on Google Cloud Storage objects, permissions must be configured at bucket level and not on object level. Hence, the accessibility must be configured on a bucket level to be uniform. It is advised to use bucket level policies, because ACLs are a legacy access control system."},"impact":0.8,"refs":[],"tags":{"sgs_wiki_url":"https://wiki.wdf.sap.corp/wiki/x/9Ik-cg","terraform_remediation":"  resource \"google_storage_bucket\" \"test-bucket\" {\n    ...\n    uniform_bucket_level_access = true\n  }\n","tested_tf_version":"1.0.11","remediation_steps":"  1.  Login to GCP console and type 'Cloud Storage' in the search bar > Click on the bucket for which the alert is raised.\n  2.  Click on 'PERMISSIONS' tab > Select access control level to be Uniform > Click Confirm.\n"},"code":"control '5_01_buckets_uniform_access_enforced' do\r\n  impact 0.8\r\n  title '5.1 - GCP Storage buckets must have Uniform access control enabled'\r\n  desc 'To prevent public access on Google Cloud Storage objects, permissions must be configured at bucket level and not on object level. Hence, the accessibility must be configured on a bucket level to be uniform. It is advised to use bucket level policies, because ACLs are a legacy access control system.'\r\n  tag sgs_wiki_url: 'https://wiki.wdf.sap.corp/wiki/x/9Ik-cg'\r\n  tag terraform_remediation: <<-EOF\r\n  resource \"google_storage_bucket\" \"test-bucket\" {\r\n    ...\r\n    uniform_bucket_level_access = true\r\n  }\r\n  EOF\r\n  tag tested_tf_version: '1.0.11'\r\n\r\n  tag remediation_steps: <<-EOF\r\n  1.  Login to GCP console and type 'Cloud Storage' in the search bar > Click on the bucket for which the alert is raised.\r\n  2.  Click on 'PERMISSIONS' tab > Select access control level to be Uniform > Click Confirm.\r\n  EOF\r\n\r\n  google_storage_buckets(project: gcp_project_id).table.entries.each do |bucket_entry|\r\n    next if bucket_entry[:bucket_name].match(/artifacts.#{gcp_project_id}.appspot.com/)\r\n\r\n    # IAM config block returns status of whether Unifrom bucket level is enabled in API response. If the block is not present, Uniform access is disabled.\r\n    if bucket_entry[:iamConfiguration].nil?\r\n      describe \"IAM configuration block for bucket #{bucket_entry[:bucket_name]} should exist\" do\r\n        subject { bucket_entry[:iamConfiguration] }\r\n        it { should_not be_nil }\r\n      end\r\n    end\r\n    next if bucket_entry[:iamConfiguration].nil?\r\n\r\n    describe \"Uniform Bucket access level for #{bucket_entry[:bucket_name]}\" do\r\n      subject { bucket_entry[:iamConfiguration]['iamConfiguration']['uniformBucketLevelAccess']['enabled'] }\r\n      it { should eq true }\r\n    end\r\n  end\r\nend\r\n","source_location":{"ref":"./controls/5_01.rb","line":75},"id":"5_01_buckets_uniform_access_enforced"},{"title":"5.4 - GCP Storage log buckets should have object versioning enabled","desc":"Object versioning on log-buckets should be enabled. Enabling object versioning on storage log buckets will protect the cloud storage data from being overwritten or accidentally deleted.","descriptions":{"default":"Object versioning on log-buckets should be enabled. Enabling object versioning on storage log buckets will protect the cloud storage data from being overwritten or accidentally deleted."},"impact":0.5,"refs":[],"tags":{"sgs_wiki_url":"https://wiki.wdf.sap.corp/wiki/x/9Ik-cg","terraform_remediation":"  resource \"google_logging_project_sink\" \"example_google_logging_project_sink\" {\n    ...\n    destination = \"google_storage_bucket.example_google_storage_bucket\"\n    ...\n  }\n\n  resource \"google_storage_bucket\" \"example_google_storage_bucket\" {\n    ...\n    versioning {\n      enabled = true\n    }\n    ...\n  }\n","tested_tf_version":"1.0.11","terraform_remediation_note":"Source range should be a specific IP CIDR range, and should not be IPv4 0.0.0.0/0, or IPv6 ::/0","remediation_steps":"  1.  Login to GCP console and type 'Cloud Storage' in the search bar > Click on the bucket for which the alert is raised.\n  2.  Click on 'CONFIGURATION' tab > Under 'Protection' > 'Object versioning' attribute should be 'On'.\n"},"code":"control '5_04_enable_storage_log_bucket_object_versioning' do\r\n  title '5.4 - GCP Storage log buckets should have object versioning enabled'\r\n  impact 0.5\r\n  desc 'Object versioning on log-buckets should be enabled. Enabling object versioning on storage log buckets will protect the cloud storage data from being overwritten or accidentally deleted.'\r\n  tag sgs_wiki_url: 'https://wiki.wdf.sap.corp/wiki/x/9Ik-cg'\r\n  tag terraform_remediation: <<-EOF\r\n  resource \"google_logging_project_sink\" \"example_google_logging_project_sink\" {\r\n    ...\r\n    destination = \"google_storage_bucket.example_google_storage_bucket\"\r\n    ...\r\n  }\r\n\r\n  resource \"google_storage_bucket\" \"example_google_storage_bucket\" {\r\n    ...\r\n    versioning {\r\n      enabled = true\r\n    }\r\n    ...\r\n  }\r\n  EOF\r\n  tag tested_tf_version: '1.0.11'\r\n  tag terraform_remediation_note: 'Source range should be a specific IP CIDR range, and should not be IPv4 0.0.0.0/0, or IPv6 ::/0'\r\n\r\n  tag remediation_steps: <<-EOF\r\n  1.  Login to GCP console and type 'Cloud Storage' in the search bar > Click on the bucket for which the alert is raised.\r\n  2.  Click on 'CONFIGURATION' tab > Under 'Protection' > 'Object versioning' attribute should be 'On'.\r\n  EOF\r\n\r\n  all_bucket_names = google_storage_buckets(project: gcp_project_id).bucket_names\r\n\r\n  google_logging_project_sinks(project: gcp_project_id).names.each do |name|\r\n    bucket_name = google_logging_project_sink(project: gcp_project_id, name: name).destination.split('/').last\r\n    next unless all_bucket_names.include?(bucket_name)\r\n    bucket = google_storage_bucket(name: bucket_name)\r\n    next unless bucket.retention_policy.retention_period.nil?\r\n    describe google_storage_bucket(name: bucket_name) do\r\n      its('versioning.enabled') { should cmp true }\r\n    end\r\n  end\r\nend\r\n","source_location":{"ref":"./controls/5_04.rb","line":3},"id":"5_04_enable_storage_log_bucket_object_versioning"},{"title":"6.1.1 - GCP Firewall rule must not allow Inbound traffic from the internet to database ports on the blocklist","desc":"This policy identifies GCP Firewall rules which allows inbound traffic to the following  DB ports\n  (5432, 3306, 4333, 1521, 27017, 1433, 1434) from public internet. Doing so, may allow a bad actor to brute\n  force their way into the system and potentially get access to the entire network.","descriptions":{"default":"This policy identifies GCP Firewall rules which allows inbound traffic to the following  DB ports\n  (5432, 3306, 4333, 1521, 27017, 1433, 1434) from public internet. Doing so, may allow a bad actor to brute\n  force their way into the system and potentially get access to the entire network."},"impact":0.8,"refs":[],"tags":{"sgs_wiki_url":"https://wiki.wdf.sap.corp/wiki/x/9Ik-cg","terraform_remediation":"  resource \"google_compute_firewall\" \"example_google_compute_firewall\" {\n    ...\n    source_ranges = <Specific IP CIDR range != 0.0.0.0/0 or ::/0>\n\n    allow {\n      protocol = \"tcp\"\n      ports    = [... 5432 3306 4333 1521 27017 1433 1434 ...]\n    }\n\n    allow {\n      protocol = \"udp\"\n      ports    = [... 5432 3306 4333 1521 27017 1433 1434 ...]\n    }\n  }\n","tested_tf_version":"1.0.11","terraform_remediation_note":"Source range must be a specific IP CIDR range, and must not be IPv4 0.0.0.0/0, or IPv6 ::/0","remediation_steps":"  1.  Login to GCP console and type firewall in the search bar.\n  2.  Under 'Firewall rules in this project' section, click on the rule for which there is an alert.\n  3.  Make sure the following rule does not exists: 'Direction' as 'Ingress', 'Source IPv4 ranges' is 0.0.0.0/0 or 'Source IPv6 ranges' is ::/0; Under 'Protocols and ports': no DB ports are included in 'tcp' or 'udp'.\n  4.  Click Save.\n"},"code":"control '6_01_01_db_ports' do\r\n  title '6.1.1 - GCP Firewall rule must not allow Inbound traffic from the internet to database ports on the blocklist'\r\n  impact 0.8\r\n  desc 'This policy identifies GCP Firewall rules which allows inbound traffic to the following  DB ports\r\n  (5432, 3306, 4333, 1521, 27017, 1433, 1434) from public internet. Doing so, may allow a bad actor to brute\r\n  force their way into the system and potentially get access to the entire network.'\r\n  tag sgs_wiki_url: 'https://wiki.wdf.sap.corp/wiki/x/9Ik-cg'\r\n  tag terraform_remediation: <<-EOF\r\n  resource \"google_compute_firewall\" \"example_google_compute_firewall\" {\r\n    ...\r\n    source_ranges = <Specific IP CIDR range != 0.0.0.0/0 or ::/0>\r\n\r\n    allow {\r\n      protocol = \"tcp\"\r\n      ports    = [... 5432 3306 4333 1521 27017 1433 1434 ...]\r\n    }\r\n\r\n    allow {\r\n      protocol = \"udp\"\r\n      ports    = [... 5432 3306 4333 1521 27017 1433 1434 ...]\r\n    }\r\n  }\r\n  EOF\r\n  tag tested_tf_version: '1.0.11'\r\n  tag terraform_remediation_note: 'Source range must be a specific IP CIDR range, and must not be IPv4 0.0.0.0/0, or IPv6 ::/0'\r\n\r\n  tag remediation_steps: <<-EOF\r\n  1.  Login to GCP console and type firewall in the search bar.\r\n  2.  Under 'Firewall rules in this project' section, click on the rule for which there is an alert.\r\n  3.  Make sure the following rule does not exists: 'Direction' as 'Ingress', 'Source IPv4 ranges' is 0.0.0.0/0 or 'Source IPv6 ranges' is ::/0; Under 'Protocols and ports': no DB ports are included in 'tcp' or 'udp'.\r\n  4.  Click Save.\r\n  EOF\r\n\r\n  check_ports = %w(5432 3306 4333 1521 27017 1433 1434)\r\n  violations = 0\r\n  google_compute_firewalls(project: gcp_project_id).where(firewall_direction: 'INGRESS').entries.each do |entry|\r\n    unless entry.target_tags.nil?\r\n      next if entry.target_tags.include? 'sec-by-def-database-port-exception'\r\n    end\r\n\r\n    next if entry.allowed.nil? || (entry.disabled == true)\r\n    entry.allowed.each do |rule|\r\n      next unless (rule.ip_protocol == 'tcp') || (rule.ip_protocol == 'udp') || (rule.ip_protocol == 'all')\r\n      next if entry.source_ranges.nil?\r\n      next unless entry.source_ranges.include?('0.0.0.0/0') || entry.source_ranges.include?('::/0')\r\n      if rule.ports.nil?\r\n        violations += 1\r\n        describe \"Firewall rule #{entry.firewall_name} must not allow internet ingress on database ports port/protocol all:#{rule.ip_protocol}\" do\r\n          subject { rule.ports }\r\n          it { should_not be_nil }\r\n        end\r\n      end\r\n      next if rule.ports.nil?\r\n      rule.ports.each do |port|\r\n        if port.include?('-')\r\n          lower = port.split('-')[0].to_i\r\n          upper = port.split('-')[1].to_i\r\n          check_ports.each do |database_port|\r\n            bad_port = database_port.to_i.between?(lower, upper)\r\n            next unless bad_port\r\n            violations += 1\r\n            describe \"Firewall rule #{entry.firewall_name} must not allow internet ingress on database ports port/protocol #{database_port}:#{rule.ip_protocol}\" do\r\n              subject { bad_port }\r\n              it { should be false }\r\n            end\r\n          end\r\n        else\r\n          check_ports.each do |database_port|\r\n            next unless database_port == port\r\n            violations += 1\r\n            describe \"Firewall rule #{entry.firewall_name} must not allow internet ingress on database ports port/protocol #{database_port}:#{rule.ip_protocol}\" do\r\n              subject { port }\r\n              it { should_not cmp database_port }\r\n            end\r\n          end\r\n        end\r\n      end\r\n    end\r\n  end\r\n  if violations == 0\r\n    # this is included so that there is PASS data when an account is compliant\r\n    describe violations do\r\n      it { should be 0 }\r\n    end\r\n  end\r\nend\r\n","source_location":{"ref":"./controls/6_01_01.rb","line":3},"id":"6_01_01_db_ports"},{"title":"6.1.2 - GCP Firewall rule must not allow Inbound traffic from then internet to admin ports on the blocklist","desc":"This policy identifies GCP Firewall rules which allows inbound traffic to the following admin ports (22, 3389, 135, 514, 5500, 59000) from public internet. Doing so, may allow a bad actor to brute force their way into the system and potentially get access to the entire network.","descriptions":{"default":"This policy identifies GCP Firewall rules which allows inbound traffic to the following admin ports (22, 3389, 135, 514, 5500, 59000) from public internet. Doing so, may allow a bad actor to brute force their way into the system and potentially get access to the entire network."},"impact":0.8,"refs":[],"tags":{"sgs_wiki_url":"https://wiki.wdf.sap.corp/wiki/x/9Ik-cg","terraform_remediation":"  resource \"google_compute_firewall\" \"example_google_compute_firewall\" {\n    ...\n    source_ranges = <Specific IP CIDR range != 0.0.0.0/0 or ::/0>\n\n    allow {\n      protocol = \"tcp\"\n      ports    = [... 3389 22 5500 5900 135 514 ...]\n    }\n\n    allow {\n      protocol = \"udp\"\n      ports    = [... 3389 22 5500 5900 135 514 ...]\n    }\n  }\n","tested_tf_version":"1.0.11","terraform_remediation_note":"Source range must be a specific IP CIDR range, and must not be IPv4 0.0.0.0/0, or IPv6 ::/0","remediation_steps":"  1.  Login to GCP console and type firewall in the search bar.\n  2.  Under 'Firewall rules in this project' section click on the rule for which there is an alert.\n  3.  Make sure the following rule does not exists: 'Direction' as 'Ingress', 'Source IPv4 ranges' is 0.0.0.0/0 or 'Source IPv6 ranges' is ::/0; Under 'Protocols and ports': no admin ports are included in 'tcp' or 'udp'.\n  4.  Click Save.\n"},"code":"control '6_01_02_admin_ports' do\r\n  title '6.1.2 - GCP Firewall rule must not allow Inbound traffic from then internet to admin ports on the blocklist'\r\n  impact 0.8\r\n  desc 'This policy identifies GCP Firewall rules which allows inbound traffic to the following admin ports (22, 3389, 135, 514, 5500, 59000) from public internet. Doing so, may allow a bad actor to brute force their way into the system and potentially get access to the entire network.'\r\n  tag sgs_wiki_url: 'https://wiki.wdf.sap.corp/wiki/x/9Ik-cg'\r\n  tag terraform_remediation: <<-EOF\r\n  resource \"google_compute_firewall\" \"example_google_compute_firewall\" {\r\n    ...\r\n    source_ranges = <Specific IP CIDR range != 0.0.0.0/0 or ::/0>\r\n\r\n    allow {\r\n      protocol = \"tcp\"\r\n      ports    = [... 3389 22 5500 5900 135 514 ...]\r\n    }\r\n\r\n    allow {\r\n      protocol = \"udp\"\r\n      ports    = [... 3389 22 5500 5900 135 514 ...]\r\n    }\r\n  }\r\n  EOF\r\n  tag tested_tf_version: '1.0.11'\r\n  tag terraform_remediation_note: 'Source range must be a specific IP CIDR range, and must not be IPv4 0.0.0.0/0, or IPv6 ::/0'\r\n\r\n  tag remediation_steps: <<-EOF\r\n  1.  Login to GCP console and type firewall in the search bar.\r\n  2.  Under 'Firewall rules in this project' section click on the rule for which there is an alert.\r\n  3.  Make sure the following rule does not exists: 'Direction' as 'Ingress', 'Source IPv4 ranges' is 0.0.0.0/0 or 'Source IPv6 ranges' is ::/0; Under 'Protocols and ports': no admin ports are included in 'tcp' or 'udp'.\r\n  4.  Click Save.\r\n  EOF\r\n\r\n  check_ports = %w(3389 22 5500 5900 135 514)\r\n  violations = 0\r\n  google_compute_firewalls(project: gcp_project_id).where(firewall_direction: 'INGRESS').entries.each do |entry|\r\n    unless entry.target_tags.nil?\r\n      next if entry.target_tags.include? 'sec-by-def-admin-port-exception'\r\n    end\r\n\r\n    next if entry.allowed.nil? || (entry.disabled == true)\r\n    entry.allowed.each do |rule|\r\n      next unless (rule.ip_protocol == 'tcp') || (rule.ip_protocol == 'udp') || (rule.ip_protocol == 'all')\r\n      next if entry.source_ranges.nil?\r\n      next unless entry.source_ranges.include?('0.0.0.0/0') || entry.source_ranges.include?('::/0')\r\n      if rule.ports.nil?\r\n        violations += 1\r\n        describe \"Firewall rule #{entry.firewall_name} must not allow internet ingress on admin ports port/protocol all:#{rule.ip_protocol}\" do\r\n          subject { rule.ports }\r\n          it { should_not be_nil }\r\n        end\r\n      end\r\n      next if rule.ports.nil?\r\n      rule.ports.each do |port|\r\n        if port.include?('-')\r\n          lower = port.split('-')[0].to_i\r\n          upper = port.split('-')[1].to_i\r\n          check_ports.each do |admin_port|\r\n            bad_port = admin_port.to_i.between?(lower, upper)\r\n            next unless bad_port\r\n            violations += 1\r\n            describe \"Firewall rule #{entry.firewall_name} must not allow internet ingress on admin ports port/protocol #{admin_port}:#{rule.ip_protocol}\" do\r\n              subject { bad_port }\r\n              it { should be false }\r\n            end\r\n          end\r\n        else\r\n          check_ports.each do |admin_port|\r\n            next unless admin_port == port\r\n            violations += 1\r\n            describe \"Firewall rule #{entry.firewall_name} must not allow internet ingress on admin ports port/protocol #{admin_port}:#{rule.ip_protocol}\" do\r\n              subject { port }\r\n              it { should_not cmp admin_port }\r\n            end\r\n          end\r\n        end\r\n      end\r\n    end\r\n  end\r\n  if violations == 0\r\n    # this is included so that there is PASS data when an account is compliant\r\n    describe violations do\r\n      it { should be 0 }\r\n    end\r\n  end\r\nend\r\n","source_location":{"ref":"./controls/6_01_02.rb","line":3},"id":"6_01_02_admin_ports"},{"title":"6.1.3 - GCP Firewall rule should not allow Inbound traffic from the internet to infrastructure ports on the blocklist","desc":"This policy identifies GCP Firewall rules which allows inbound traffic to the following infrastructure ports\n  (53, 110, 25, 67, 68, 161, 162) from public internet. Doing so, may allow a bad actor to brute force their way\n  into the system and potentially get access to the entire network.","descriptions":{"default":"This policy identifies GCP Firewall rules which allows inbound traffic to the following infrastructure ports\n  (53, 110, 25, 67, 68, 161, 162) from public internet. Doing so, may allow a bad actor to brute force their way\n  into the system and potentially get access to the entire network."},"impact":0.5,"refs":[],"tags":{"sgs_wiki_url":"https://wiki.wdf.sap.corp/wiki/x/9Ik-cg","terraform_remediation":"  resource \"google_compute_firewall\" \"example_google_compute_firewall\" {\n    ...\n    source_ranges = <Specific IP CIDR range != 0.0.0.0/0 or ::/0>\n\n    allow {\n      protocol = \"tcp\"\n      ports    = [... 53 110 25 67 68 161 162 ...]\n    }\n\n    allow {\n      protocol = \"udp\"\n      ports    = [... 53 110 25 67 68 161 162 ...]\n    }\n  }\n","tested_tf_version":"1.0.11","terraform_remediation_note":"Source range should be a specific IP CIDR range, and should not be IPv4 0.0.0.0/0, or IPv6 ::/0","remediation_steps":"  1.  Login to GCP console and type firewall in the search bar.\n  2.  Under 'Firewall rules in this project' section, click on the rule for which there is an alert.\n  3. Navigate to the inbound rules > Click on Edit Inbound rules > Ensure CIDR block 0.0.0.0/0 or ::/0 is not bound to any of the following ports: 53, 110, 25, 67, 68, 161, 162 OR any ports mentioned in [6.1.3 Firewall Rules for Infrastructure ports] SGS hardening guidelines > Save rules.\n"},"code":"control '6_01_03_infra_ports' do\r\n  title '6.1.3 - GCP Firewall rule should not allow Inbound traffic from the internet to infrastructure ports on the blocklist'\r\n  impact 0.5\r\n  desc 'This policy identifies GCP Firewall rules which allows inbound traffic to the following infrastructure ports\r\n  (53, 110, 25, 67, 68, 161, 162) from public internet. Doing so, may allow a bad actor to brute force their way\r\n  into the system and potentially get access to the entire network.'\r\n  tag sgs_wiki_url: 'https://wiki.wdf.sap.corp/wiki/x/9Ik-cg'\r\n  tag terraform_remediation: <<-EOF\r\n  resource \"google_compute_firewall\" \"example_google_compute_firewall\" {\r\n    ...\r\n    source_ranges = <Specific IP CIDR range != 0.0.0.0/0 or ::/0>\r\n\r\n    allow {\r\n      protocol = \"tcp\"\r\n      ports    = [... 53 110 25 67 68 161 162 ...]\r\n    }\r\n\r\n    allow {\r\n      protocol = \"udp\"\r\n      ports    = [... 53 110 25 67 68 161 162 ...]\r\n    }\r\n  }\r\n  EOF\r\n  tag tested_tf_version: '1.0.11'\r\n  tag terraform_remediation_note: 'Source range should be a specific IP CIDR range, and should not be IPv4 0.0.0.0/0, or IPv6 ::/0'\r\n\r\n  tag remediation_steps: <<-EOF\r\n  1.  Login to GCP console and type firewall in the search bar.\r\n  2.  Under 'Firewall rules in this project' section, click on the rule for which there is an alert.\r\n  3. Navigate to the inbound rules > Click on Edit Inbound rules > Ensure CIDR block 0.0.0.0/0 or ::/0 is not bound to any of the following ports: 53, 110, 25, 67, 68, 161, 162 OR any ports mentioned in [6.1.3 Firewall Rules for Infrastructure ports] SGS hardening guidelines > Save rules.\r\n  EOF\r\n\r\n  check_ports = %w(53 110 25 67 68 161 162)\r\n  violations = 0\r\n  google_compute_firewalls(project: gcp_project_id).where(firewall_direction: 'INGRESS').entries.each do |entry|\r\n    unless entry.target_tags.nil?\r\n      next if entry.target_tags.include? 'sec-by-def-infrastructure-port-exception'\r\n    end\r\n\r\n    next if entry.allowed.nil? || (entry.disabled == true)\r\n    entry.allowed.each do |rule|\r\n      next unless (rule.ip_protocol == 'tcp') || (rule.ip_protocol == 'udp') || (rule.ip_protocol == 'all')\r\n      next if entry.source_ranges.nil?\r\n      next unless entry.source_ranges.include?('0.0.0.0/0') || entry.source_ranges.include?('::/0')\r\n      if rule.ports.nil?\r\n        violations += 1\r\n        describe \"Firewall rule #{entry.firewall_name} should not allow internet ingress on infrastructure ports port/protocol all:#{rule.ip_protocol}\" do\r\n          subject { rule.ports }\r\n          it { should_not be_nil }\r\n        end\r\n      end\r\n      next if rule.ports.nil?\r\n      rule.ports.each do |port|\r\n        if port.include?('-')\r\n          lower = port.split('-')[0].to_i\r\n          upper = port.split('-')[1].to_i\r\n          check_ports.each do |infrastructure_port|\r\n            bad_port = infrastructure_port.to_i.between?(lower, upper)\r\n            next unless bad_port\r\n            violations += 1\r\n            describe \"Firewall rule #{entry.firewall_name} should not allow internet ingress on infrastructure ports port/protocol #{infrastructure_port}:#{rule.ip_protocol}\" do\r\n              subject { bad_port }\r\n              it { should be false }\r\n            end\r\n          end\r\n        else\r\n          check_ports.each do |infrastructure_port|\r\n            next unless infrastructure_port == port\r\n            violations += 1\r\n            describe \"Firewall rule #{entry.firewall_name} should not allow internet ingress on infrastructure ports port/protocol #{infrastructure_port}:#{rule.ip_protocol}\" do\r\n              subject { port }\r\n              it { should_not cmp infrastructure_port }\r\n            end\r\n          end\r\n        end\r\n      end\r\n    end\r\n  end\r\n  if violations == 0\r\n    # this is included so that there is PASS data when an account is compliant\r\n    describe violations do\r\n      it { should be 0 }\r\n    end\r\n  end\r\nend\r\n","source_location":{"ref":"./controls/6_01_03.rb","line":3},"id":"6_01_03_infra_ports"},{"title":"6.1.4 - GCP Firewall rule should not allow Inbound traffic from the internet to file sharing ports on the blocklist","desc":"This policy identifies GCP Firewall rules which allows inbound traffic to the following file sharing ports (139, 445, 21, 69)\n  from public internet. Doing so, may allow a bad actor to brute force their way into the system and potentially get access to the entire network.","descriptions":{"default":"This policy identifies GCP Firewall rules which allows inbound traffic to the following file sharing ports (139, 445, 21, 69)\n  from public internet. Doing so, may allow a bad actor to brute force their way into the system and potentially get access to the entire network."},"impact":0.5,"refs":[],"tags":{"sgs_wiki_url":"https://wiki.wdf.sap.corp/wiki/x/9Ik-cg","terraform_remediation":"  resource \"google_compute_firewall\" \"example_google_compute_firewall\" {\n    ...\n    source_ranges = <Specific IP CIDR range != 0.0.0.0/0 or ::/0>\n\n    allow {\n      protocol = \"tcp\"\n      ports    = [... 139 445 21 69 ...]\n    }\n\n    allow {\n      protocol = \"udp\"\n      ports    = [... 139 445 21 69 ...]\n    }\n  }\n","tested_tf_version":"1.0.11","terraform_remediation_note":"Source range should be a specific IP CIDR range, and should not be IPv4 0.0.0.0/0, or IPv6 ::/0","remediation_steps":"  1.  Login to GCP console and type firewall in the search bar.\n  2.  Under 'Firewall rules in this project' section, click on the rule for which there is an alert.\n  3.  Make sure the following rule does not exists: 'Direction' as 'Ingress', 'Source IPv4 ranges' is 0.0.0.0/0 or 'Source IPv6 ranges' is ::/0; Under 'Protocols and ports': no infrastructure ports are included in 'tcp' or 'udp'.\n  4.  Click Save.\n"},"code":"control '6_01_04_fileshare_ports' do\r\n  title '6.1.4 - GCP Firewall rule should not allow Inbound traffic from the internet to file sharing ports on the blocklist'\r\n  impact 0.5\r\n  desc 'This policy identifies GCP Firewall rules which allows inbound traffic to the following file sharing ports (139, 445, 21, 69)\r\n  from public internet. Doing so, may allow a bad actor to brute force their way into the system and potentially get access to the entire network.'\r\n  tag sgs_wiki_url: 'https://wiki.wdf.sap.corp/wiki/x/9Ik-cg'\r\n  tag terraform_remediation: <<-EOF\r\n  resource \"google_compute_firewall\" \"example_google_compute_firewall\" {\r\n    ...\r\n    source_ranges = <Specific IP CIDR range != 0.0.0.0/0 or ::/0>\r\n\r\n    allow {\r\n      protocol = \"tcp\"\r\n      ports    = [... 139 445 21 69 ...]\r\n    }\r\n\r\n    allow {\r\n      protocol = \"udp\"\r\n      ports    = [... 139 445 21 69 ...]\r\n    }\r\n  }\r\n  EOF\r\n  tag tested_tf_version: '1.0.11'\r\n  tag terraform_remediation_note: 'Source range should be a specific IP CIDR range, and should not be IPv4 0.0.0.0/0, or IPv6 ::/0'\r\n\r\n  tag remediation_steps: <<-EOF\r\n  1.  Login to GCP console and type firewall in the search bar.\r\n  2.  Under 'Firewall rules in this project' section, click on the rule for which there is an alert.\r\n  3.  Make sure the following rule does not exists: 'Direction' as 'Ingress', 'Source IPv4 ranges' is 0.0.0.0/0 or 'Source IPv6 ranges' is ::/0; Under 'Protocols and ports': no infrastructure ports are included in 'tcp' or 'udp'.\r\n  4.  Click Save.\r\n  EOF\r\n\r\n  check_ports = %w(139 445 21 69)\r\n  violations = 0\r\n  google_compute_firewalls(project: gcp_project_id).where(firewall_direction: 'INGRESS').entries.each do |entry|\r\n    unless entry.target_tags.nil?\r\n      next if entry.target_tags.include? 'sec-by-def-fileshare-port-exception'\r\n    end\r\n\r\n    next if entry.allowed.nil? || (entry.disabled == true)\r\n    entry.allowed.each do |rule|\r\n      next unless (rule.ip_protocol == 'tcp') || (rule.ip_protocol == 'udp') || (rule.ip_protocol == 'all')\r\n      next if entry.source_ranges.nil?\r\n      next unless entry.source_ranges.include?('0.0.0.0/0') || entry.source_ranges.include?('::/0')\r\n      if rule.ports.nil?\r\n        violations += 1\r\n        describe \"Firewall rule #{entry.firewall_name} should not allow internet ingress on fileshare ports port/protocol all:#{rule.ip_protocol}\" do\r\n          subject { rule.ports }\r\n          it { should_not be_nil }\r\n        end\r\n      end\r\n      next if rule.ports.nil?\r\n      rule.ports.each do |port|\r\n        if port.include?('-')\r\n          lower = port.split('-')[0].to_i\r\n          upper = port.split('-')[1].to_i\r\n          check_ports.each do |fileshare_port|\r\n            bad_port = fileshare_port.to_i.between?(lower, upper)\r\n            next unless bad_port\r\n            violations += 1\r\n            describe \"Firewall rule #{entry.firewall_name} should not allow internet ingress on fileshare ports port/protocol #{fileshare_port}:#{rule.ip_protocol}\" do\r\n              subject { bad_port }\r\n              it { should be false }\r\n            end\r\n          end\r\n        else\r\n          check_ports.each do |fileshare_port|\r\n            next unless fileshare_port == port\r\n            violations += 1\r\n            describe \"Firewall rule #{entry.firewall_name} should not allow internet ingress on fileshare ports port/protocol #{fileshare_port}:#{rule.ip_protocol}\" do\r\n              subject { port }\r\n              it { should_not cmp fileshare_port }\r\n            end\r\n          end\r\n        end\r\n      end\r\n    end\r\n  end\r\n  if violations == 0\r\n    # this is included so that there is PASS data when an account is compliant\r\n    describe violations do\r\n      it { should be 0 }\r\n    end\r\n  end\r\nend\r\n","source_location":{"ref":"./controls/6_01_04.rb","line":3},"id":"6_01_04_fileshare_ports"},{"title":"6.1.5 - GCP Firewall rule must not allow Inbound traffic from the internet to blocklisted port 23","desc":"This policy identifies GCP Firewall rules which allows inbound traffic to the following blocklisted DB ports (23) from public internet.\n  Doing so, may allow a bad actor to brute force their way into the system and potentially get access to the entire network.","descriptions":{"default":"This policy identifies GCP Firewall rules which allows inbound traffic to the following blocklisted DB ports (23) from public internet.\n  Doing so, may allow a bad actor to brute force their way into the system and potentially get access to the entire network."},"impact":0.8,"refs":[],"tags":{"sgs_wiki_url":"https://wiki.wdf.sap.corp/wiki/x/9Ik-cg","terraform_remediation":"  resource \"google_compute_firewall\" \"example_google_compute_firewall\" {\n    ...\n    source_ranges = <Specific IP CIDR range != 0.0.0.0/0 or ::/0>\n\n    allow {\n      protocol = \"tcp\"\n      ports    = [... 23 ...]\n    }\n\n    allow {\n      protocol = \"udp\"\n      ports    = [... 23 ...]\n    }\n  }\n","tested_tf_version":"1.0.11","terraform_remediation_note":"Source range must be a specific IP CIDR range, and must not be IPv4 0.0.0.0/0, or IPv6 ::/0","remediation_steps":"  1.  Login to GCP console and type firewall in the search bar.\n  2.  Under 'Firewall rules in this project' section, click on the rule for which there is an alert.\n  3.  Make sure the following rule does not exists: 'Direction' as 'Ingress', 'Source IPv4 ranges' is 0.0.0.0/0 or 'Source IPv6 ranges' is ::/0; Under 'Protocols and ports': no infrastructure ports are included in 'tcp' or 'udp'.\n  4.  Click Save.\n"},"code":"control '6_01_05_telnet_ports' do\r\n  title '6.1.5 - GCP Firewall rule must not allow Inbound traffic from the internet to blocklisted port 23'\r\n  impact 0.8\r\n  desc 'This policy identifies GCP Firewall rules which allows inbound traffic to the following blocklisted DB ports (23) from public internet.\r\n  Doing so, may allow a bad actor to brute force their way into the system and potentially get access to the entire network.'\r\n  tag sgs_wiki_url: 'https://wiki.wdf.sap.corp/wiki/x/9Ik-cg'\r\n  tag terraform_remediation: <<-EOF\r\n  resource \"google_compute_firewall\" \"example_google_compute_firewall\" {\r\n    ...\r\n    source_ranges = <Specific IP CIDR range != 0.0.0.0/0 or ::/0>\r\n\r\n    allow {\r\n      protocol = \"tcp\"\r\n      ports    = [... 23 ...]\r\n    }\r\n\r\n    allow {\r\n      protocol = \"udp\"\r\n      ports    = [... 23 ...]\r\n    }\r\n  }\r\n  EOF\r\n  tag tested_tf_version: '1.0.11'\r\n  tag terraform_remediation_note: 'Source range must be a specific IP CIDR range, and must not be IPv4 0.0.0.0/0, or IPv6 ::/0'\r\n\r\n  tag remediation_steps: <<-EOF\r\n  1.  Login to GCP console and type firewall in the search bar.\r\n  2.  Under 'Firewall rules in this project' section, click on the rule for which there is an alert.\r\n  3.  Make sure the following rule does not exists: 'Direction' as 'Ingress', 'Source IPv4 ranges' is 0.0.0.0/0 or 'Source IPv6 ranges' is ::/0; Under 'Protocols and ports': no infrastructure ports are included in 'tcp' or 'udp'.\r\n  4.  Click Save.\r\n  EOF\r\n\r\n  check_ports = %w(23)\r\n  violations = 0\r\n  google_compute_firewalls(project: gcp_project_id).where(firewall_direction: 'INGRESS').entries.each do |entry|\r\n    unless entry.target_tags.nil?\r\n      next if entry.target_tags.include? 'sec-by-def-telnet-port-exception'\r\n    end\r\n\r\n    next if entry.allowed.nil? || (entry.disabled == true)\r\n    entry.allowed.each do |rule|\r\n      next unless (rule.ip_protocol == 'tcp') || (rule.ip_protocol == 'udp') || (rule.ip_protocol == 'all')\r\n      next if entry.source_ranges.nil?\r\n      next unless entry.source_ranges.include?('0.0.0.0/0') || entry.source_ranges.include?('::/0')\r\n      if rule.ports.nil?\r\n        violations += 1\r\n        describe \"Firewall rule #{entry.firewall_name} must not allow internet ingress on telnet ports port/protocol all:#{rule.ip_protocol}\" do\r\n          subject { rule.ports }\r\n          it { should_not be_nil }\r\n        end\r\n      end\r\n      next if rule.ports.nil?\r\n      rule.ports.each do |port|\r\n        if port.include?('-')\r\n          lower = port.split('-')[0].to_i\r\n          upper = port.split('-')[1].to_i\r\n          check_ports.each do |telnet_port|\r\n            bad_port = telnet_port.to_i.between?(lower, upper)\r\n            next unless bad_port\r\n            violations += 1\r\n            describe \"Firewall rule #{entry.firewall_name} must not allow internet ingress on telnet ports port/protocol #{telnet_port}:#{rule.ip_protocol}\" do\r\n              subject { bad_port }\r\n              it { should be false }\r\n            end\r\n          end\r\n        else\r\n          check_ports.each do |telnet_port|\r\n            next unless telnet_port == port\r\n            violations += 1\r\n            describe \"Firewall rule #{entry.firewall_name} must not allow internet ingress on telnet ports port/protocol #{telnet_port}:#{rule.ip_protocol}\" do\r\n              subject { port }\r\n              it { should_not cmp telnet_port }\r\n            end\r\n          end\r\n        end\r\n      end\r\n    end\r\n  end\r\n  if violations == 0\r\n    # this is included so that there is PASS data when an account is compliant\r\n    describe violations do\r\n      it { should be 0 }\r\n    end\r\n  end\r\nend\r\n","source_location":{"ref":"./controls/6_01_05.rb","line":3},"id":"6_01_05_telnet_ports"},{"title":"6.3 - GCP load balancer must be configured with SSL policy having TLS version 1.2 or higher","desc":"The configuration of the GCP https load balancer SSL policy MUST be configured at least with TLS version 1.2 and higher.","descriptions":{"default":"The configuration of the GCP https load balancer SSL policy MUST be configured at least with TLS version 1.2 and higher."},"impact":0.8,"refs":[],"tags":{"sgs_control_hash":"8ae223887226fcbd01722703b9830024","sgs_wiki_url":"https://wiki.wdf.sap.corp/wiki/x/9Ik-cg","terraform_remediation":"  resource \"google_compute_target_https_proxy\" \"example_https_proxy\" {\n    ...\n    ssl_policy       = <configured google compute ssl policy>\n  }\n  resource \"google_compute_ssl_policy\" \"example_ssl_policy\" {\n    ...\n    min_tls_version = \"TLS_1_2\"\n  }\n","tested_tf_version":"1.0.11","remediation_steps":"  1.  Sign in to GCP Portal.\n  2.  Navigate to Cloud Load Balancing dashboard (or search for Load Balancing in the search bar).\n  3.  On the Load balancing page > select Load balancers > Choose the HTTPS/SSL Proxy load balancer that the alert is about >  Click on the 3-dot button > then select edit.\n  4.  On the Edit HTTP(S) load balancer page > select Frontend configuration tab > click on frontend configuration > click on the downward facing arrow.\n  5.  On the frontend configuration panel, select the appropriate SSL policy, which uses, at the minimum, TLS 1.2 OR if there is no SSL policy >  create a new SSL policy with, at the minimum, TLS 1.2.\n  6.  On the Edit HTTP(S) load balancer page > click Update.\n"},"code":"control '6_03_secure_load_balancer_configuration' do\r\n  impact 0.8\r\n  title '6.3 - GCP load balancer must be configured with SSL policy having TLS version 1.2 or higher'\r\n  desc 'The configuration of the GCP https load balancer SSL policy MUST be configured at least with TLS version 1.2 and higher.'\r\n\r\n  tag sgs_control_hash: '8ae223887226fcbd01722703b9830024'\r\n  tag sgs_wiki_url: 'https://wiki.wdf.sap.corp/wiki/x/9Ik-cg'\r\n  tag terraform_remediation: <<-EOF\r\n  resource \"google_compute_target_https_proxy\" \"example_https_proxy\" {\r\n    ...\r\n    ssl_policy       = <configured google compute ssl policy>\r\n  }\r\n  resource \"google_compute_ssl_policy\" \"example_ssl_policy\" {\r\n    ...\r\n    min_tls_version = \"TLS_1_2\"\r\n  }\r\n  EOF\r\n  tag tested_tf_version: '1.0.11'\r\n\r\n  tag remediation_steps: <<-EOF\r\n  1.  Sign in to GCP Portal.\r\n  2.  Navigate to Cloud Load Balancing dashboard (or search for Load Balancing in the search bar).\r\n  3.  On the Load balancing page > select Load balancers > Choose the HTTPS/SSL Proxy load balancer that the alert is about >  Click on the 3-dot button > then select edit.\r\n  4.  On the Edit HTTP(S) load balancer page > select Frontend configuration tab > click on frontend configuration > click on the downward facing arrow.\r\n  5.  On the frontend configuration panel, select the appropriate SSL policy, which uses, at the minimum, TLS 1.2 OR if there is no SSL policy >  create a new SSL policy with, at the minimum, TLS 1.2.\r\n  6.  On the Edit HTTP(S) load balancer page > click Update.\r\n  EOF\r\n\r\n  google_compute_target_https_proxies(project: gcp_project_id).names.each do |load_balancer|\r\n    describe google_compute_target_https_proxy(project: gcp_project_id, name: load_balancer) do\r\n      its('ssl_policy') { should_not be_nil }\r\n    end\r\n\r\n    ssl_policy_url = google_compute_target_https_proxy(project: gcp_project_id, name: load_balancer).ssl_policy\r\n    next if ssl_policy_url.nil?\r\n    # Get policy name from:\r\n    # https://www.googleapis.com/compute/v1/projects/PROJECT/global/sslPolicies/SSLPOLICYNAME\r\n    ssl_policy_name = ssl_policy_url.split('/').last\r\n\r\n    describe \"TargetHttpsProxy #{load_balancer} ssl_policy #{ssl_policy_name}\" do\r\n      subject { google_compute_ssl_policy(project: gcp_project_id, name: ssl_policy_name) }\r\n      its('min_tls_version') { should eq 'TLS_1_2' }\r\n    end\r\n  end\r\nend\r\n","source_location":{"ref":"./controls/6_03.rb","line":5},"id":"6_03_secure_load_balancer_configuration"},{"title":"6.4 GCP VPN connections must use IKEv2","desc":"The IKEv1 protocol is outdated and MUST NOT be used. Configure VPN connections with IKEv2 whenever possible.","descriptions":{"default":"The IKEv1 protocol is outdated and MUST NOT be used. Configure VPN connections with IKEv2 whenever possible."},"impact":0.8,"refs":[],"tags":{"sgs_wiki_url":"https://wiki.wdf.sap.corp/wiki/x/9Ik-cg","terraform_remediation":"  resource \"google_compute_vpn_tunnel\" \"example_vpn_tunnel\" {\n    ...\n    ike_version = 2\n    ...\n  }\n","tested_tf_version":"1.0.11","remediation_steps":"  1.  Sign in to GCP Portal.\n  2.  Navigate to VPN dashboard (or search for vpn in the search bar).\n  3.  select vpn tunnel for which alerts is raised.\n  4.  Under Details -> Routing and security section, IKE version must be IKEv2.\n"},"code":"control '6_04_gcp_vpn_secure_configuration' do\r\n  impact 0.8\r\n  title '6.4 GCP VPN connections must use IKEv2'\r\n  desc 'The IKEv1 protocol is outdated and MUST NOT be used. Configure VPN connections with IKEv2 whenever possible.'\r\n  tag sgs_wiki_url: 'https://wiki.wdf.sap.corp/wiki/x/9Ik-cg'\r\n  tag terraform_remediation: <<-EOF\r\n  resource \"google_compute_vpn_tunnel\" \"example_vpn_tunnel\" {\r\n    ...\r\n    ike_version = 2\r\n    ...\r\n  }\r\n  EOF\r\n  tag tested_tf_version: '1.0.11'\r\n\r\n  tag remediation_steps: <<-EOF\r\n  1.  Sign in to GCP Portal.\r\n  2.  Navigate to VPN dashboard (or search for vpn in the search bar).\r\n  3.  select vpn tunnel for which alerts is raised.\r\n  4.  Under Details -> Routing and security section, IKE version must be IKEv2.\r\n  EOF\r\n\r\n  google_compute_regions(project: gcp_project_id).region_names.each do |region_name|\r\n    google_compute_vpn_tunnels(project: gcp_project_id, region: region_name).vpn_tunnel_names.each do |vpn_tunnel|\r\n      describe google_compute_vpn_tunnel(project: gcp_project_id, region: region_name, name: vpn_tunnel) do\r\n        its('ike_version') { should_not eq 1 }\r\n      end\r\n    end\r\n  end\r\nend\r\n","source_location":{"ref":"./controls/6_04.rb","line":3},"id":"6_04_gcp_vpn_secure_configuration"},{"title":"7.4 - GCP Kubernetes Engine Clusters should have Master authorized networks enabled","desc":"Enabling Master authorized networks will let the Kubernetes Engine block untrusted non-GCP source IPs from accessing the Kubernetes master through HTTPS. This control identifies Kubernetes Engine Clusters which have disabled Master authorized networks.","descriptions":{"default":"Enabling Master authorized networks will let the Kubernetes Engine block untrusted non-GCP source IPs from accessing the Kubernetes master through HTTPS. This control identifies Kubernetes Engine Clusters which have disabled Master authorized networks."},"impact":0.5,"refs":[],"tags":{"sgs_wiki_url":"https://wiki.wdf.sap.corp/wiki/x/9Ik-cg","terraform_remediation":"  resource \"google_container_cluster\" \"example_google_container_cluster\" {\n  ...\n    master_authorized_networks_config {\n    }\n  ...\n  }\n","tested_tf_version":"1.0.11","terraform_remediation_note":"Omit the nested cidr_blocks attribute to disallow external access (except the cluster node IPs, which GKE automatically whitelists).","remediation_steps":"  1.  Login to GCP console and type Kuberbetes Clusters in the search bar > Click on the cluster for which the alert is raised.\n  2.  In the Details tab under Networking > 'Control plane authorized networks' attribute should be 'Enabled'.\n"},"code":"control '7_04_gke_master_authorized_networks' do\r\n  title '7.4 - GCP Kubernetes Engine Clusters should have Master authorized networks enabled'\r\n  impact 0.5\r\n  desc 'Enabling Master authorized networks will let the Kubernetes Engine block untrusted non-GCP source IPs from accessing the Kubernetes master through HTTPS. This control identifies Kubernetes Engine Clusters which have disabled Master authorized networks.'\r\n  tag sgs_wiki_url: 'https://wiki.wdf.sap.corp/wiki/x/9Ik-cg'\r\n  tag terraform_remediation: <<-EOF\r\n  resource \"google_container_cluster\" \"example_google_container_cluster\" {\r\n  ...\r\n    master_authorized_networks_config {\r\n    }\r\n  ...\r\n  }\r\n  EOF\r\n  tag tested_tf_version: '1.0.11'\r\n  tag terraform_remediation_note: 'Omit the nested cidr_blocks attribute to disallow external access (except the cluster node IPs, which GKE automatically whitelists).'\r\n\r\n  tag remediation_steps: <<-EOF\r\n  1.  Login to GCP console and type Kuberbetes Clusters in the search bar > Click on the cluster for which the alert is raised.\r\n  2.  In the Details tab under Networking > 'Control plane authorized networks' attribute should be 'Enabled'.\r\n  EOF\r\n\r\n  google_compute_regions(project: gcp_project_id).region_names.each do |region_name|\r\n    google_container_clusters(project: gcp_project_id, location: region_name).entries.each do |gke_cluster|\r\n      if gke_cluster.master_authorized_networks_config.nil?\r\n\r\n        describe \"Master authorized networks config for #{gke_cluster.cluster_name} cluster in region #{region_name}\" do\r\n          subject { gke_cluster.master_authorized_networks_config }\r\n          it { should_not be_nil }\r\n        end\r\n      else\r\n\r\n        describe \"Master authorized networks config should be enabled for #{gke_cluster.cluster_name} in region #{region_name}\" do\r\n          subject { gke_cluster.master_authorized_networks_config.enabled }\r\n          it { should eq true }\r\n        end\r\n      end\r\n    end\r\n  end\r\nend\r\n","source_location":{"ref":"./controls/7_04.rb","line":3},"id":"7_04_gke_master_authorized_networks"},{"title":"7.4 - GCP GKE must have supported Master node version","desc":"This control enforces your GKE master node version to be valid and generates an alert if the version running is unsupported.","descriptions":{"default":"This control enforces your GKE master node version to be valid and generates an alert if the version running is unsupported."},"impact":0.8,"refs":[],"tags":{"sgs_wiki_url":"https://wiki.wdf.sap.corp/wiki/x/9Ik-cg","terraform_remediation":"  resource \"google_container_cluster\" \"example_google_container_cluster\" {\n    ...\n    min_master_version = data.google_container_engine_versions.example_container_engine_version.latest_node_version\n    ...\n  }\n\n  data \"google_container_engine_versions\" \"example_container_engine_version\" {\n    ...\n    version_prefix = \"latest\"\n  }\n","tested_tf_version":"1.0.11","remediation_steps":"  1. Login to GCP console and type Kuberbetes Clusters in the search bar > Click on the cluster for which the alert is raised.\n  2. In the Details tab, under Cluster basics > value of Version must be from the list of supported versions which can be found here: <https://cloud.google.com/kubernetes-engine/docs/release-notes>\n"},"code":"control '7_04_gke_unsupported_master_version' do\r\n  title '7.4 - GCP GKE must have supported Master node version'\r\n  impact 0.8\r\n  desc 'This control enforces your GKE master node version to be valid and generates an alert if the version running is unsupported.'\r\n  tag sgs_wiki_url: 'https://wiki.wdf.sap.corp/wiki/x/9Ik-cg'\r\n  tag terraform_remediation: <<-EOF\r\n  resource \"google_container_cluster\" \"example_google_container_cluster\" {\r\n    ...\r\n    min_master_version = data.google_container_engine_versions.example_container_engine_version.latest_node_version\r\n    ...\r\n  }\r\n\r\n  data \"google_container_engine_versions\" \"example_container_engine_version\" {\r\n    ...\r\n    version_prefix = \"latest\"\r\n  }\r\n  EOF\r\n  tag tested_tf_version: '1.0.11'\r\n\r\n  tag remediation_steps: <<-EOF\r\n  1. Login to GCP console and type Kuberbetes Clusters in the search bar > Click on the cluster for which the alert is raised.\r\n  2. In the Details tab, under Cluster basics > value of Version must be from the list of supported versions which can be found here: <https://cloud.google.com/kubernetes-engine/docs/release-notes>\r\n  EOF\r\n\r\n  google_compute_regions(project: gcp_project_id).region_names.each do |region_name|\r\n    google_container_clusters(project: gcp_project_id, location: region_name).cluster_names.each do |cluster_name|\r\n      gke_master_version = google_container_cluster(project: gcp_project_id, location: region_name, name: cluster_name).current_master_version\r\n      describe google_container_server_config(project: gcp_project_id, location: region_name) do\r\n        its('valid_master_versions') { should include gke_master_version }\r\n      end\r\n    end\r\n  end\r\nend\r\n","source_location":{"ref":"./controls/7_04.rb","line":43},"id":"7_04_gke_unsupported_master_version"},{"title":"7.4 - GCP GKE must have supported node version","desc":"This control enforces your GKE node version to be valid and generates an alert if the version running is unsupported.","descriptions":{"default":"This control enforces your GKE node version to be valid and generates an alert if the version running is unsupported."},"impact":0.8,"refs":[],"tags":{"sgs_wiki_url":"https://wiki.wdf.sap.corp/wiki/x/9Ik-cg","terraform_remediation":"  resource \"google_container_cluster\" \"example_google_container_cluster\" {\n    ...\n    node_version = data.google_container_engine_versions.example_container_engine_version.latest_node_version\n  }\n\n  data \"google_container_engine_versions\" \"example_container_engine_version\" {\n    ...\n    version_prefix = \"latest\"\n  }\n","tested_tf_version":"1.0.11","remediation_steps":"  1.  Login to GCP console and type Kuberbetes Clusters in the search bar > Click on the cluster for which the alert is raised.\n  2.  Click on NODES tab > Click on one of the Node pool > The value of 'Node version' must be from the list of supported versions which can be found here: <https://cloud.google.com/kubernetes-engine/docs/release-notes>.\n"},"code":"control '7_04_gke_unsupported_node_version' do\r\n  title '7.4 - GCP GKE must have supported node version'\r\n  impact 0.8\r\n  desc 'This control enforces your GKE node version to be valid and generates an alert if the version running is unsupported.'\r\n  tag sgs_wiki_url: 'https://wiki.wdf.sap.corp/wiki/x/9Ik-cg'\r\n  tag terraform_remediation: <<-EOF\r\n  resource \"google_container_cluster\" \"example_google_container_cluster\" {\r\n    ...\r\n    node_version = data.google_container_engine_versions.example_container_engine_version.latest_node_version\r\n  }\r\n\r\n  data \"google_container_engine_versions\" \"example_container_engine_version\" {\r\n    ...\r\n    version_prefix = \"latest\"\r\n  }\r\n  EOF\r\n  tag tested_tf_version: '1.0.11'\r\n\r\n  tag remediation_steps: <<-EOF\r\n  1.  Login to GCP console and type Kuberbetes Clusters in the search bar > Click on the cluster for which the alert is raised.\r\n  2.  Click on NODES tab > Click on one of the Node pool > The value of 'Node version' must be from the list of supported versions which can be found here: <https://cloud.google.com/kubernetes-engine/docs/release-notes>.\r\n  EOF\r\n\r\n  google_compute_regions(project: gcp_project_id).region_names.each do |region_name|\r\n    google_container_clusters(project: gcp_project_id, location: region_name).cluster_names.each do |cluster_name|\r\n      gke_node_version = google_container_cluster(project: gcp_project_id, location: region_name, name: cluster_name).current_node_version\r\n      describe google_container_server_config(project: gcp_project_id, location: region_name) do\r\n        its('valid_node_versions') { should include gke_node_version }\r\n      end\r\n    end\r\n  end\r\nend\r\n","source_location":{"ref":"./controls/7_04.rb","line":77},"id":"7_04_gke_unsupported_node_version"},{"title":"7.6 - GCP Kubernetes Engine Clusters should have Stackdriver Monitoring enabled","desc":"This control identifies Kubernetes Engine Clusters which have disabled Stackdriver monitoring.\n  Enabling Stackdriver monitoring will let the Kubernetes Engine to monitor signals and build operations in the clusters.","descriptions":{"default":"This control identifies Kubernetes Engine Clusters which have disabled Stackdriver monitoring.\n  Enabling Stackdriver monitoring will let the Kubernetes Engine to monitor signals and build operations in the clusters."},"impact":0.5,"refs":[],"tags":{"sgs_wiki_url":"https://wiki.wdf.sap.corp/wiki/x/9Ik-cg","terraform_remediation":"  resource \"google_container_cluster\" \"example_google_container_cluster\" {\n    ...\n    monitoring_service = <Valid monitoring service>\n    ...\n  }\n","tested_tf_version":"1.0.11","terraform_remediation_note":"Available options include monitoring.googleapis.com(Legacy Stackdriver), monitoring.googleapis.com/kubernetes(Stackdriver Kubernetes Engine Monitoring), and none. Defaults to monitoring.googleapis.com/kubernetes.","remediation_steps":"  1.  Login to GCP console and type Kuberbetes Clusters in the search bar > Click on the cluster for which the alert is raised.\n  2.  In the Details tab, under Features > 'Cloud Monitoring' attribute should be 'Enabled'.\n"},"code":"control '7_06_gke_stackdriver_monitoring_enabled' do\r\n  title '7.6 - GCP Kubernetes Engine Clusters should have Stackdriver Monitoring enabled'\r\n  impact 0.5\r\n  desc 'This control identifies Kubernetes Engine Clusters which have disabled Stackdriver monitoring.\r\n  Enabling Stackdriver monitoring will let the Kubernetes Engine to monitor signals and build operations in the clusters.'\r\n  tag sgs_wiki_url: 'https://wiki.wdf.sap.corp/wiki/x/9Ik-cg'\r\n  tag terraform_remediation: <<-EOF\r\n  resource \"google_container_cluster\" \"example_google_container_cluster\" {\r\n    ...\r\n    monitoring_service = <Valid monitoring service>\r\n    ...\r\n  }\r\n  EOF\r\n  tag tested_tf_version: '1.0.11'\r\n  tag terraform_remediation_note: 'Available options include monitoring.googleapis.com(Legacy Stackdriver), monitoring.googleapis.com/kubernetes(Stackdriver Kubernetes Engine Monitoring), and none. Defaults to monitoring.googleapis.com/kubernetes.'\r\n\r\n  tag remediation_steps: <<-EOF\r\n  1.  Login to GCP console and type Kuberbetes Clusters in the search bar > Click on the cluster for which the alert is raised.\r\n  2.  In the Details tab, under Features > 'Cloud Monitoring' attribute should be 'Enabled'.\r\n  EOF\r\n\r\n  google_compute_regions(project: gcp_project_id).region_names.each do |region_name|\r\n    google_container_clusters(project: gcp_project_id, location: region_name).entries.each do |gke_cluster|\r\n      describe \"Monitoring Service for #{gke_cluster.cluster_name}\" do\r\n        subject { gke_cluster.monitoring_service }\r\n        it { should_not eq 'none' }\r\n      end\r\n    end\r\n  end\r\nend\r\n","source_location":{"ref":"./controls/7_06.rb","line":3},"id":"7_06_gke_stackdriver_monitoring_enabled"},{"title":"7.6 - GCP Kubernetes Engine Clusters should have Legacy Authorization disabled","desc":"Enabling Legacy Authorization grants permissions to all cluster users. After Legacy Authorization is disabled, RBAC can limit permissions for authorized users based on need. This control identifies GCP Kubernetes Engine Clusters which have enabled legacy authorizer.","descriptions":{"default":"Enabling Legacy Authorization grants permissions to all cluster users. After Legacy Authorization is disabled, RBAC can limit permissions for authorized users based on need. This control identifies GCP Kubernetes Engine Clusters which have enabled legacy authorizer."},"impact":0.5,"refs":[],"tags":{"sgs_wiki_url":"https://wiki.wdf.sap.corp/wiki/x/9Ik-cg","terraform_remediation":"  resource \"google_container_cluster\" \"example_google_container_cluster\" {\n    ...\n    enable_legacy_abac = false\n    ...\n  }\n","tested_tf_version":"1.0.11","remediation_steps":"  1.  Login to GCP console and type Kubernetes Clusters in the search bar > Click on the cluster for which the alert is raised.\n  2.  In the Details tab under Security > 'Legacy authorization' attribute should be 'Disabled'.\n"},"code":"control '7_06_gke_legacy_authorization_enabled' do\r\n  title '7.6 - GCP Kubernetes Engine Clusters should have Legacy Authorization disabled'\r\n  impact 0.5\r\n  desc 'Enabling Legacy Authorization grants permissions to all cluster users. After Legacy Authorization is disabled, RBAC can limit permissions for authorized users based on need. This control identifies GCP Kubernetes Engine Clusters which have enabled legacy authorizer.'\r\n  tag sgs_wiki_url: 'https://wiki.wdf.sap.corp/wiki/x/9Ik-cg'\r\n  tag terraform_remediation: <<-EOF\r\n  resource \"google_container_cluster\" \"example_google_container_cluster\" {\r\n    ...\r\n    enable_legacy_abac = false\r\n    ...\r\n  }\r\n  EOF\r\n  tag tested_tf_version: '1.0.11'\r\n\r\n  tag remediation_steps: <<-EOF\r\n  1.  Login to GCP console and type Kubernetes Clusters in the search bar > Click on the cluster for which the alert is raised.\r\n  2.  In the Details tab under Security > 'Legacy authorization' attribute should be 'Disabled'.\r\n  EOF\r\n\r\n  google_compute_regions(project: gcp_project_id).region_names.each do |region_name|\r\n    google_container_clusters(project: gcp_project_id, location: region_name).entries.each do |gke_cluster|\r\n      describe \"Legacy ABAC for #{gke_cluster.cluster_name}\" do\r\n        subject { gke_cluster.legacy_abac.enabled }\r\n        it { should_not eq true }\r\n      end\r\n    end\r\n  end\r\nend\r\n","source_location":{"ref":"./controls/7_06.rb","line":34},"id":"7_06_gke_legacy_authorization_enabled"},{"title":"7.11 - GCP Kubernetes Engine Clusters Basic Authentication should be disabled","desc":"Basic authentication allows a user to authenticate to the cluster with\n  a username and password and it is stored in plain text without any encryption.\n  Basic authentication should be disabled to prevent attacks like brute force.\n  Its recommended to use either client certificate or IAM for authentication.\n\n  If the master_auth block is provided and both username and password are empty,\n  basic authentication will be disabled.","descriptions":{"default":"Basic authentication allows a user to authenticate to the cluster with\n  a username and password and it is stored in plain text without any encryption.\n  Basic authentication should be disabled to prevent attacks like brute force.\n  Its recommended to use either client certificate or IAM for authentication.\n\n  If the master_auth block is provided and both username and password are empty,\n  basic authentication will be disabled."},"impact":0.5,"refs":[],"tags":{"sgs_wiki_url":"https://wiki.wdf.sap.corp/wiki/x/9Ik-cg","terraform_remediation":"  resource \"google_container_cluster\" \"example_google_container_cluster\" {\n    ...\n    master_auth {\n      client_certificate_config {\n        ....\n      }\n    }\n    ...\n  }\n","tested_tf_version":"1.0.11","terraform_remediation_note":"Basic authentication should be disabled to prevent attacks like brute force. If the master_auth block is provided and both username and password are empty, basic authentication will be disabled.","remediation_steps":"  1.  Login to GCP console and type Kubernetes Clusters in the search bar > Click on the cluster for which the alert is raised.\n  2.  In the Details tab, under Security > 'Basic authentication' attribute should be 'Disabled'.\n"},"code":"control '7_11_disable_gke_basic_authentication' do\r\n  title '7.11 - GCP Kubernetes Engine Clusters Basic Authentication should be disabled'\r\n  impact 0.5\r\n  desc \"Basic authentication allows a user to authenticate to the cluster with\r\n  a username and password and it is stored in plain text without any encryption.\r\n  Basic authentication should be disabled to prevent attacks like brute force.\r\n  Its recommended to use either client certificate or IAM for authentication.\r\n\r\n  If the master_auth block is provided and both username and password are empty,\r\n  basic authentication will be disabled.\"\r\n  tag sgs_wiki_url: 'https://wiki.wdf.sap.corp/wiki/x/9Ik-cg'\r\n  tag terraform_remediation: <<-EOF\r\n  resource \"google_container_cluster\" \"example_google_container_cluster\" {\r\n    ...\r\n    master_auth {\r\n      client_certificate_config {\r\n        ....\r\n      }\r\n    }\r\n    ...\r\n  }\r\n  EOF\r\n  tag tested_tf_version: '1.0.11'\r\n  tag terraform_remediation_note: 'Basic authentication should be disabled to prevent attacks like brute force. If the master_auth block is provided and both username and password are empty, basic authentication will be disabled.'\r\n\r\n  tag remediation_steps: <<-EOF\r\n  1.  Login to GCP console and type Kubernetes Clusters in the search bar > Click on the cluster for which the alert is raised.\r\n  2.  In the Details tab, under Security > 'Basic authentication' attribute should be 'Disabled'.\r\n  EOF\r\n\r\n  google_compute_regions(project: gcp_project_id).region_names.each do |region_name|\r\n    google_container_clusters(project: gcp_project_id, location: region_name).entries.each do |gke_cluster|\r\n      describe \"Basic master username for #{gke_cluster.cluster_name}\" do\r\n        subject { gke_cluster.master_auth.username }\r\n        it { should eq nil }\r\n      end\r\n      describe \"Basic master password for #{gke_cluster.cluster_name}\" do\r\n        subject { gke_cluster.master_auth.password }\r\n        it { should eq nil }\r\n      end\r\n    end\r\n  end\r\nend\r\n","source_location":{"ref":"./controls/7_11.rb","line":3},"id":"7_11_disable_gke_basic_authentication"},{"title":"7.12 - GCP Kubernetes Engine Clusters should be configured with private nodes feature","desc":"This control enables the private cluster feature, creating a private\n  endpoint on the cluster. In a private cluster, nodes only have RFC 1918\n  private addresses and communicate with the master's private endpoint via\n  private networking.\n\n  Private clusters use nodes that do not have external IP addresses. This means\n  that clients on the internet cannot connect to the IP addresses of the nodes.\n  Apart from that, based on the use case of the used GKE cluster, the private\n  node feature SHOULD be used to make the master node inaccessible from the\n  internet to add an additional line of defense by ensuring that the container\n  workloads are isolated from the internet.","descriptions":{"default":"This control enables the private cluster feature, creating a private\n  endpoint on the cluster. In a private cluster, nodes only have RFC 1918\n  private addresses and communicate with the master's private endpoint via\n  private networking.\n\n  Private clusters use nodes that do not have external IP addresses. This means\n  that clients on the internet cannot connect to the IP addresses of the nodes.\n  Apart from that, based on the use case of the used GKE cluster, the private\n  node feature SHOULD be used to make the master node inaccessible from the\n  internet to add an additional line of defense by ensuring that the container\n  workloads are isolated from the internet."},"impact":0.5,"refs":[],"tags":{"sgs_wiki_url":"https://wiki.wdf.sap.corp/wiki/x/9Ik-cg","terraform_remediation":"  resource \"google_container_cluster\" \"example_google_container_cluster\" {\n    ...\n    private_cluster_config {\n      enable_private_nodes    = true\n      enable_private_endpoint = true\n    }\n    ...\n  }\n","tested_tf_version":"1.0.11","remediation_steps":"  1.  Login to GCP console and type Kuberbetes Clusters in the search bar > Click on the cluster for which the alert is raised.\n  2.  In the Details tab, under Networking > 'Private cluster' attribute should be 'Enabled'.\n"},"code":"control '7_12_enable_gke_cluster_private_nodes' do\r\n  title '7.12 - GCP Kubernetes Engine Clusters should be configured with private nodes feature'\r\n  impact 0.5\r\n  desc \"This control enables the private cluster feature, creating a private\r\n  endpoint on the cluster. In a private cluster, nodes only have RFC 1918\r\n  private addresses and communicate with the master's private endpoint via\r\n  private networking.\r\n\r\n  Private clusters use nodes that do not have external IP addresses. This means\r\n  that clients on the internet cannot connect to the IP addresses of the nodes.\r\n  Apart from that, based on the use case of the used GKE cluster, the private\r\n  node feature SHOULD be used to make the master node inaccessible from the\r\n  internet to add an additional line of defense by ensuring that the container\r\n  workloads are isolated from the internet.\"\r\n  tag sgs_wiki_url: 'https://wiki.wdf.sap.corp/wiki/x/9Ik-cg'\r\n  tag terraform_remediation: <<-EOF\r\n  resource \"google_container_cluster\" \"example_google_container_cluster\" {\r\n    ...\r\n    private_cluster_config {\r\n      enable_private_nodes    = true\r\n      enable_private_endpoint = true\r\n    }\r\n    ...\r\n  }\r\n  EOF\r\n  tag tested_tf_version: '1.0.11'\r\n\r\n  tag remediation_steps: <<-EOF\r\n  1.  Login to GCP console and type Kuberbetes Clusters in the search bar > Click on the cluster for which the alert is raised.\r\n  2.  In the Details tab, under Networking > 'Private cluster' attribute should be 'Enabled'.\r\n  EOF\r\n\r\n  google_compute_regions(project: gcp_project_id).region_names.each do |region_name|\r\n    google_container_clusters(project: gcp_project_id, location: region_name).entries.each do |gke_cluster|\r\n      describe \"private cluster config for #{gke_cluster.cluster_name}\" do\r\n        subject { gke_cluster.private_cluster_config }\r\n        it { should_not be_nil }\r\n      end\r\n      next if gke_cluster.private_cluster_config.nil?\r\n      describe \"private nodes for cluster config #{gke_cluster.cluster_name}\" do\r\n        subject { gke_cluster.private_cluster_config.enable_private_nodes }\r\n        it { should eq true }\r\n      end\r\n    end\r\n  end\r\nend\r\n","source_location":{"ref":"./controls/7_12.rb","line":3},"id":"7_12_enable_gke_cluster_private_nodes"},{"title":"7.15 - GCP Kubernetes Engine Clusters should use Container-Optimized OS for Node image","desc":"Container-Optimized OS is used for your Compute Engine VMs that is optimized for running Docker containers. Container-Optimized OS for node image enables to bring up your Docker containers on Google Cloud Platform quickly, efficiently, and securely. The Container-Optimized OS node image is based on most recent version of the Linux kernel to enhance node security. The Container-Optimized OS image provides good support, security, and stability than other images. This control identifies Kubernetes Engine Clusters which do not have a container-optimized operating system for node image.","descriptions":{"default":"Container-Optimized OS is used for your Compute Engine VMs that is optimized for running Docker containers. Container-Optimized OS for node image enables to bring up your Docker containers on Google Cloud Platform quickly, efficiently, and securely. The Container-Optimized OS node image is based on most recent version of the Linux kernel to enhance node security. The Container-Optimized OS image provides good support, security, and stability than other images. This control identifies Kubernetes Engine Clusters which do not have a container-optimized operating system for node image."},"impact":0.5,"refs":[],"tags":{"sgs_wiki_url":"https://wiki.wdf.sap.corp/wiki/x/9Ik-cg","terraform_remediation":"  resource \"google_container_cluster\" \"example_google_container_cluster\" {\n    ...\n    node_config {\n      ...\n      image_type = <Valid image type>\n    }\n    ...\n  }\n","tested_tf_version":"1.0.11","terraform_remediation_note":"Please note that according to the official documentation the value should be one of the [COS_CONTAINERD, COS, UBUNTU_CONTAINERD, UBUNTU]. This control requires either COS_CONTAINERD OR COS.","remediation_steps":"  1.  Login to GCP console and type Kubernetes Clusters in the search bar > Click on the cluster for which the alert is raised.\n  2.  Click Nodes tab > Click on the Node pool > Click on EDIT > Under Nodes -> Image type > click on CHANGE > Select 'cos_containerd'.\n  3.  Click CHANGE.\n"},"code":"control '7_15_gke_container_optimized_node_image' do\r\n  title '7.15 - GCP Kubernetes Engine Clusters should use Container-Optimized OS for Node image'\r\n  impact 0.5\r\n  desc 'Container-Optimized OS is used for your Compute Engine VMs that is optimized for running Docker containers. Container-Optimized OS for node image enables to bring up your Docker containers on Google Cloud Platform quickly, efficiently, and securely. The Container-Optimized OS node image is based on most recent version of the Linux kernel to enhance node security. The Container-Optimized OS image provides good support, security, and stability than other images. This control identifies Kubernetes Engine Clusters which do not have a container-optimized operating system for node image.'\r\n  tag sgs_wiki_url: 'https://wiki.wdf.sap.corp/wiki/x/9Ik-cg'\r\n  tag terraform_remediation: <<-EOF\r\n  resource \"google_container_cluster\" \"example_google_container_cluster\" {\r\n    ...\r\n    node_config {\r\n      ...\r\n      image_type = <Valid image type>\r\n    }\r\n    ...\r\n  }\r\n  EOF\r\n  tag tested_tf_version: '1.0.11'\r\n  tag terraform_remediation_note: 'Please note that according to the official documentation the value should be one of the [COS_CONTAINERD, COS, UBUNTU_CONTAINERD, UBUNTU]. This control requires either COS_CONTAINERD OR COS.'\r\n\r\n  tag remediation_steps: <<-EOF\r\n  1.  Login to GCP console and type Kubernetes Clusters in the search bar > Click on the cluster for which the alert is raised.\r\n  2.  Click Nodes tab > Click on the Node pool > Click on EDIT > Under Nodes -> Image type > click on CHANGE > Select 'cos_containerd'.\r\n  3.  Click CHANGE.\r\n  EOF\r\n\r\n  google_compute_regions(project: gcp_project_id).region_names.each do |region_name|\r\n    google_container_clusters(project: gcp_project_id, location: region_name).entries.each do |gke_cluster|\r\n      next if gke_cluster.node_config.nil?\r\n\r\n      describe \"Node config Image type for #{gke_cluster.cluster_name}\" do\r\n        subject { gke_cluster.node_config.image_type }\r\n        it { should match /COS/ }\r\n      end\r\n    end\r\n  end\r\nend\r\n","source_location":{"ref":"./controls/7_15.rb","line":3},"id":"7_15_gke_container_optimized_node_image"},{"title":"8.1 - Caching services must use transit encryption and latest software version","desc":"As of Q1 2022 Redis version 6 must be used over Redis version 4 which is already near its EoL (End of Life).\n  Encryption in-transit (TLS) must be activated.","descriptions":{"default":"As of Q1 2022 Redis version 6 must be used over Redis version 4 which is already near its EoL (End of Life).\n  Encryption in-transit (TLS) must be activated."},"impact":0.8,"refs":[],"tags":{"sgs_wiki_url":"https://wiki.wdf.sap.corp/wiki/x/9Ik-cg","terraform_remediation":"  resource \"google_redis_instance\" \"example_redis_instance\" {\n    transit_encryption_mode = 'SERVER_AUTHENTICATION'\n    redis_version           = 'REDIS_6_X'\n  }\n","tested_tf_version":"1.0.11","remediation_steps":"  1. Login to GCP console and type Memorystore in the search bar > Click on the instance for which the alert is raised.\n  2. In the top bar, select Edit.\n  3. Enable in-transit encryption.\n  4. Click Save\n  5. On the main instance page, in the Configuration box, next to the Redis version select \"UPGRADE\"\n  6. Choose version 6.x or higher, and then upgrade.\n"},"code":"control '8_01_caching_encryption_and_versioning' do\r\n  title '8.1 - Caching services must use transit encryption and latest software version'\r\n  impact 0.8\r\n  desc 'As of Q1 2022 Redis version 6 must be used over Redis version 4 which is already near its EoL (End of Life).\r\n  Encryption in-transit (TLS) must be activated.'\r\n  tag sgs_wiki_url: 'https://wiki.wdf.sap.corp/wiki/x/9Ik-cg'\r\n  tag terraform_remediation: <<-EOF\r\n  resource \"google_redis_instance\" \"example_redis_instance\" {\r\n    transit_encryption_mode = 'SERVER_AUTHENTICATION'\r\n    redis_version           = 'REDIS_6_X'\r\n  }\r\n  EOF\r\n  tag tested_tf_version: '1.0.11'\r\n\r\n  tag remediation_steps: <<-EOF\r\n  1. Login to GCP console and type Memorystore in the search bar > Click on the instance for which the alert is raised.\r\n  2. In the top bar, select Edit.\r\n  3. Enable in-transit encryption.\r\n  4. Click Save\r\n  5. On the main instance page, in the Configuration box, next to the Redis version select \"UPGRADE\"\r\n  6. Choose version 6.x or higher, and then upgrade.\r\n  EOF\r\n\r\n  google_compute_regions(project: gcp_project_id).region_names.each do |region_name|\r\n    google_redis_instances(project: gcp_project_id, region: region_name).names.each do |redis_instance_name|\r\n      instance_name = redis_instance_name.split('/').last\r\n      describe google_redis_instance(project: gcp_project_id, region: region_name, name: instance_name) do\r\n        its('redis_version') { should cmp 'REDIS_6_X' }\r\n        its('transit_encryption_mode') { should cmp 'SERVER_AUTHENTICATION' }\r\n      end\r\n    end\r\n  end\r\nend\r\n","source_location":{"ref":"./controls/8_01.rb","line":3},"id":"8_01_caching_encryption_and_versioning"},{"title":"8.1 - Caching services should have secure network configuration and redundant setup of caching services","desc":"The firewall rules Should allow access only for the necessary communication partners and leverage private endpoint or networks.\n  It is important that the caching cluster is setup in an redundant (high available) way using at least the STANDARD tier level of the service. The BASIC tier should not be used because it does not offer an SLA or replication.","descriptions":{"default":"The firewall rules Should allow access only for the necessary communication partners and leverage private endpoint or networks.\n  It is important that the caching cluster is setup in an redundant (high available) way using at least the STANDARD tier level of the service. The BASIC tier should not be used because it does not offer an SLA or replication."},"impact":0.5,"refs":[],"tags":{"sgs_wiki_url":"https://wiki.wdf.sap.corp/wiki/x/9Ik-cg","terraform_remediation":"  resource \"google_redis_instance\" \"example_redis_instance\" {\n    tier                    = 'STANARD_HA'\n    authorized_network      = (IP address either in the 10.* range, 172.16-172.31 range, or 192.168 range. Also should end with /29 block)\n    connect_mode            = 'PRIVATE_SERVICE_ACCESS'\n  }\n","tested_tf_version":"1.0.11","remediation_steps":"  These parameters are not able to be edited within a resource. To make these changes, a new instance should be created.\n  1.  Login to GCP console and type Memorystore in the search bar.\n  2.  In the top bar, select Create Instance.\n  3.  Give the Redis instance a unique Instance ID, select the Standard Tier.\n  4.  Select a network which has private services access connection. In advanced network options, choose Private service access, or specify a custom IP range with a private IP address.\n  5. Click create.\n"},"code":"control '8_01_caching_network_and_availability' do\r\n  title '8.1 - Caching services should have secure network configuration and redundant setup of caching services'\r\n  impact 0.5\r\n  desc 'The firewall rules Should allow access only for the necessary communication partners and leverage private endpoint or networks.\r\n  It is important that the caching cluster is setup in an redundant (high available) way using at least the STANDARD tier level of the service. The BASIC tier should not be used because it does not offer an SLA or replication.'\r\n  tag sgs_wiki_url: 'https://wiki.wdf.sap.corp/wiki/x/9Ik-cg'\r\n  tag terraform_remediation: <<-EOF\r\n  resource \"google_redis_instance\" \"example_redis_instance\" {\r\n    tier                    = 'STANARD_HA'\r\n    authorized_network      = (IP address either in the 10.* range, 172.16-172.31 range, or 192.168 range. Also should end with /29 block)\r\n    connect_mode            = 'PRIVATE_SERVICE_ACCESS'\r\n  }\r\n  EOF\r\n  tag tested_tf_version: '1.0.11'\r\n\r\n  tag remediation_steps: <<-EOF\r\n  These parameters are not able to be edited within a resource. To make these changes, a new instance should be created.\r\n  1.  Login to GCP console and type Memorystore in the search bar.\r\n  2.  In the top bar, select Create Instance.\r\n  3.  Give the Redis instance a unique Instance ID, select the Standard Tier.\r\n  4.  Select a network which has private services access connection. In advanced network options, choose Private service access, or specify a custom IP range with a private IP address.\r\n  5. Click create.\r\n  EOF\r\n\r\n  google_compute_regions(project: gcp_project_id).region_names.each do |region_name|\r\n    google_redis_instances(project: gcp_project_id, region: region_name).names.each do |redis_instance_name|\r\n      instance_name = redis_instance_name.split('/').last\r\n      describe google_redis_instance(project: gcp_project_id, region: region_name, name: instance_name) do\r\n        its('tier') { should_not cmp 'BASIC' }\r\n        its('reserved_ip_range') { should match /(^10\\.)|(^172\\.1[6-9]\\.)|(^172\\.2[0-9]\\.)|(^172\\.3[0-1]\\.)|(^192\\.168\\.)/ }\r\n        its('connect_mode') { should cmp 'PRIVATE_SERVICE_ACCESS' }\r\n      end\r\n    end\r\n  end\r\nend\r\n","source_location":{"ref":"./controls/8_01.rb","line":37},"id":"8_01_caching_network_and_availability"},{"title":"8.3 - GCP SQL Instances must have SSL configured","desc":"This control is used to determine whether SSL connections over IP are\n  enforced or not, as well as whether a valid Certificate Authority certificate\n  is being used. SSL provides a secure channel between two machines or devices\n  operating over the internet or an internal network.\n  Cloud SQL supports connecting to an instance using the Transport Layer Security\n  (SSL/TLS) protocol. Data in transit inside a physical boundary controlled by\n  or on behalf of Google is generally authenticated but might not be encrypted\n  by default. If you connect to an instance using its public IP address, use\n  SSL/TLS certificates, so the data is secure during transmission. SSL/TLS is\n  the standard protocol for encryption of data sent over the internet. If your\n  data isn't encrypted, anyone can examine your packets and read confidential\n  information.\n  A server Certificate Authority (CA) certificate is required in SSL connections.\n  Cloud SQL creates a server certificate automatically when you create your\n  instance. As long as the server certificate is valid, you do not need to\n  actively manage your server certificate. However, the certificate has an\n  expiration date of 10 years; after that date, it is no longer valid, and\n  clients are not able to establish a secure connection to your instance using\n  that certificate.\n  The Unix epoch (or Unix time or POSIX time or Unix timestamp) is the number of\n  seconds that have elapsed since January 1, 1970 (midnight UTC/GMT). We check\n  that the number of seconds since epoch for the expiration date of the\n  certificate is greater than the number of seconds since epoch for the current\n  time. If it fails, then the certificate is expired.","descriptions":{"default":"This control is used to determine whether SSL connections over IP are\n  enforced or not, as well as whether a valid Certificate Authority certificate\n  is being used. SSL provides a secure channel between two machines or devices\n  operating over the internet or an internal network.\n  Cloud SQL supports connecting to an instance using the Transport Layer Security\n  (SSL/TLS) protocol. Data in transit inside a physical boundary controlled by\n  or on behalf of Google is generally authenticated but might not be encrypted\n  by default. If you connect to an instance using its public IP address, use\n  SSL/TLS certificates, so the data is secure during transmission. SSL/TLS is\n  the standard protocol for encryption of data sent over the internet. If your\n  data isn't encrypted, anyone can examine your packets and read confidential\n  information.\n  A server Certificate Authority (CA) certificate is required in SSL connections.\n  Cloud SQL creates a server certificate automatically when you create your\n  instance. As long as the server certificate is valid, you do not need to\n  actively manage your server certificate. However, the certificate has an\n  expiration date of 10 years; after that date, it is no longer valid, and\n  clients are not able to establish a secure connection to your instance using\n  that certificate.\n  The Unix epoch (or Unix time or POSIX time or Unix timestamp) is the number of\n  seconds that have elapsed since January 1, 1970 (midnight UTC/GMT). We check\n  that the number of seconds since epoch for the expiration date of the\n  certificate is greater than the number of seconds since epoch for the current\n  time. If it fails, then the certificate is expired."},"impact":0.8,"refs":[],"tags":{"sgs_wiki_url":"https://wiki.wdf.sap.corp/wiki/x/9Ik-cg","terraform_remediation":"  resource \"google_sql_database_instance\" \"example_sql_db_instance\" {\n    ...\n    settings {\n      ...\n      ip_configuration {\n        require_ssl = true\n        ...\n      }\n    }\n  }\n","tested_tf_version":"1.0.11","remediation_steps":"  1.  Login to GCP console and type SQL in the search bar > Click on the SQL database instance for which the alert is raised.\n  2.  Click on 'Connections' tab > Click on 'Security' tab > check 'Allow only SSL connections' box.\n"},"code":"control '8_03_sql_instance_configure_ssl' do\r\n  title '8.3 - GCP SQL Instances must have SSL configured'\r\n  impact 0.8\r\n  desc \"This control is used to determine whether SSL connections over IP are\r\n  enforced or not, as well as whether a valid Certificate Authority certificate\r\n  is being used. SSL provides a secure channel between two machines or devices\r\n  operating over the internet or an internal network.\r\n  Cloud SQL supports connecting to an instance using the Transport Layer Security\r\n  (SSL/TLS) protocol. Data in transit inside a physical boundary controlled by\r\n  or on behalf of Google is generally authenticated but might not be encrypted\r\n  by default. If you connect to an instance using its public IP address, use\r\n  SSL/TLS certificates, so the data is secure during transmission. SSL/TLS is\r\n  the standard protocol for encryption of data sent over the internet. If your\r\n  data isn't encrypted, anyone can examine your packets and read confidential\r\n  information.\r\n  A server Certificate Authority (CA) certificate is required in SSL connections.\r\n  Cloud SQL creates a server certificate automatically when you create your\r\n  instance. As long as the server certificate is valid, you do not need to\r\n  actively manage your server certificate. However, the certificate has an\r\n  expiration date of 10 years; after that date, it is no longer valid, and\r\n  clients are not able to establish a secure connection to your instance using\r\n  that certificate.\r\n  The Unix epoch (or Unix time or POSIX time or Unix timestamp) is the number of\r\n  seconds that have elapsed since January 1, 1970 (midnight UTC/GMT). We check\r\n  that the number of seconds since epoch for the expiration date of the\r\n  certificate is greater than the number of seconds since epoch for the current\r\n  time. If it fails, then the certificate is expired.\"\r\n  tag sgs_wiki_url: 'https://wiki.wdf.sap.corp/wiki/x/9Ik-cg'\r\n  tag terraform_remediation: <<-EOF\r\n  resource \"google_sql_database_instance\" \"example_sql_db_instance\" {\r\n    ...\r\n    settings {\r\n      ...\r\n      ip_configuration {\r\n        require_ssl = true\r\n        ...\r\n      }\r\n    }\r\n  }\r\n  EOF\r\n  tag tested_tf_version: '1.0.11'\r\n\r\n  tag remediation_steps: <<-EOF\r\n  1.  Login to GCP console and type SQL in the search bar > Click on the SQL database instance for which the alert is raised.\r\n  2.  Click on 'Connections' tab > Click on 'Security' tab > check 'Allow only SSL connections' box.\r\n  EOF\r\n\r\n  google_sql_database_instances(project: gcp_project_id).instance_names.each do |instance_name|\r\n    describe google_sql_database_instance(project: gcp_project_id, database: instance_name) do\r\n      its('settings.ip_configuration.require_ssl') { should eq true }\r\n      its('server_ca_cert.cert') { should_not be nil }\r\n      its('server_ca_cert.expiration_time.to_i') { should be > Time.now.to_i }\r\n    end\r\n  end\r\nend\r\n","source_location":{"ref":"./controls/8_03.rb","line":3},"id":"8_03_sql_instance_configure_ssl"},{"title":"8.3 - GCP SQL Instances must not be exposed to the internet","desc":"It must be ensured that SQL instance do not have any authorization to allow network traffic from the internet.","descriptions":{"default":"It must be ensured that SQL instance do not have any authorization to allow network traffic from the internet."},"impact":0.8,"refs":[],"tags":{"sgs_wiki_url":"https://wiki.wdf.sap.corp/wiki/x/9Ik-cg","terraform_remediation":"  resource \"google_sql_database_instance\" \"example_sql_db_instance\" {\n    ...\n    settings {\n      ...\n      ip_configuration {\n        ...\n        authorized_networks {\n          value = <list of allowed IP CIDRs>\n        }\n      }\n    }\n  }\n","tested_tf_version":"1.0.11","terraform_remediation_note":"The values of allowed CIDR IPs must either be empty (no value set) or not be equal to \"0.0.0.0/0\""},"code":"control '8_03_sql_instance_network_authorization' do\r\n  title '8.3 - GCP SQL Instances must not be exposed to the internet'\r\n  impact 0.8\r\n  desc 'It must be ensured that SQL instance do not have any authorization to allow network traffic from the internet.'\r\n  tag sgs_wiki_url: 'https://wiki.wdf.sap.corp/wiki/x/9Ik-cg'\r\n  tag sgs_wiki_url: 'https://wiki.wdf.sap.corp/wiki/x/9Ik-cg'\r\n  tag terraform_remediation: <<-EOF\r\n  resource \"google_sql_database_instance\" \"example_sql_db_instance\" {\r\n    ...\r\n    settings {\r\n      ...\r\n      ip_configuration {\r\n        ...\r\n        authorized_networks {\r\n          value = <list of allowed IP CIDRs>\r\n        }\r\n      }\r\n    }\r\n  }\r\n  EOF\r\n  tag tested_tf_version: '1.0.11'\r\n  tag terraform_remediation_note: 'The values of allowed CIDR IPs must either be empty (no value set) or not be equal to \"0.0.0.0/0\"'\r\n\r\n  google_sql_database_instances(project: gcp_project_id).instance_names.each do |instance_name|\r\n    authorized_networks_list = google_sql_database_instance(project: gcp_project_id, database: instance_name).settings.ip_configuration.authorized_networks\r\n    next if authorized_networks_list.nil? || authorized_networks_list.empty?\r\n\r\n    authorized_networks_list.entries.each do |entry|\r\n      describe entry do\r\n        its('value') { should_not eq '0.0.0.0/0' }\r\n      end\r\n    end\r\n  end\r\nend\r\n","source_location":{"ref":"./controls/8_03.rb","line":59},"id":"8_03_sql_instance_network_authorization"},{"title":"8.4 - GCP Cloud DNS zones using RSASHA1 algorithm for DNSSEC key-signing and DNSSEC zone-signing should be enabled","desc":"DNSSEC helps mitigate the risk of such attacks by cryptographically signing DNS records.\n    As a result, it prevents attackers from issuing fake DNS responses that may misdirect browsers to fake websites.\n    Therefore, DNSSEC SHOULD be enabled.","descriptions":{"default":"DNSSEC helps mitigate the risk of such attacks by cryptographically signing DNS records.\n    As a result, it prevents attackers from issuing fake DNS responses that may misdirect browsers to fake websites.\n    Therefore, DNSSEC SHOULD be enabled."},"impact":0.5,"refs":[],"tags":{"sgs_wiki_url":"https://wiki.wdf.sap.corp/wiki/x/9Ik-cg","terraform_remediation":"  resource \"google_dns_managed_zone\" \"example_dns_managed_zone\" {\n    ...\n    dnssec_config {\n      state = \"on\"\n      default_key_specs {\n        algorithm = <encryption algorithm that isn't rsasha1 (ex rsasha256)>\n        key_length = <value greater than or equal to 2048>\n        ...\n      }\n      ...\n    }\n  }\n","tested_tf_version":"1.0.11","remediation_steps":"  At the moment, DNSSEC zone-signing can only be changed using command line interface/terminal.\n  1.  If you need to updated the settings for a managed zone where it's been enabled, you have to turn DNSSEC off and then re-enable it with altered settings.\n    To turn off DNSSEC, run following command:\n\n    gcloud dns managed-zones update <ZONE_NAME> --dnssec-state off\n\n  2.  To update zone-signing for a reported managed DNS Zone, run following command:\n\n    gcloud dns managed-zones update <ZONE_NAME> --dnssec-state on --ksk-algorithm <KSK_ALGORITHM> --ksk-key-length <KSK_KEY_LENGTH> --zsk-algorithm <ZSK_ALGORITHM> --zsk-key-length <ZSK_KEY_LENGTH> --denial-of-existence <DENIAL_OF_EXISTENCE>\n"},"code":"control '8_04_dnssec_enabled' do\r\n  title '8.4 - GCP Cloud DNS zones using RSASHA1 algorithm for DNSSEC key-signing and DNSSEC zone-signing should be enabled'\r\n  impact 0.5\r\n  desc 'DNSSEC helps mitigate the risk of such attacks by cryptographically signing DNS records.\r\n    As a result, it prevents attackers from issuing fake DNS responses that may misdirect browsers to fake websites.\r\n    Therefore, DNSSEC SHOULD be enabled.'\r\n  tag sgs_wiki_url: 'https://wiki.wdf.sap.corp/wiki/x/9Ik-cg'\r\n  tag terraform_remediation: <<-EOF\r\n  resource \"google_dns_managed_zone\" \"example_dns_managed_zone\" {\r\n    ...\r\n    dnssec_config {\r\n      state = \"on\"\r\n      default_key_specs {\r\n        algorithm = <encryption algorithm that isn't rsasha1 (ex rsasha256)>\r\n        key_length = <value greater than or equal to 2048>\r\n        ...\r\n      }\r\n      ...\r\n    }\r\n  }\r\n  EOF\r\n  tag tested_tf_version: '1.0.11'\r\n\r\n  tag remediation_steps: <<-EOF\r\n  At the moment, DNSSEC zone-signing can only be changed using command line interface/terminal.\r\n  1.  If you need to updated the settings for a managed zone where it's been enabled, you have to turn DNSSEC off and then re-enable it with altered settings.\r\n    To turn off DNSSEC, run following command:\r\n\r\n    gcloud dns managed-zones update <ZONE_NAME> --dnssec-state off\r\n\r\n  2.  To update zone-signing for a reported managed DNS Zone, run following command:\r\n\r\n    gcloud dns managed-zones update <ZONE_NAME> --dnssec-state on --ksk-algorithm <KSK_ALGORITHM> --ksk-key-length <KSK_KEY_LENGTH> --zsk-algorithm <ZSK_ALGORITHM> --zsk-key-length <ZSK_KEY_LENGTH> --denial-of-existence <DENIAL_OF_EXISTENCE>\r\n  EOF\r\n\r\n  google_dns_managed_zones(project: gcp_project_id).where(visibility: 'public').zone_names.each do |zone_name|\r\n    managed_zone = google_dns_managed_zone(project: gcp_project_id, zone: zone_name)\r\n    describe managed_zone do\r\n      its('dnssec_config.state') { should match 'on' }\r\n    end\r\n    next unless managed_zone.dnssec_config.state == 'on'\r\n    managed_zone.dnssec_config.default_key_specs.each do |spec|\r\n      describe spec do\r\n        its('key_length') { should be >= 2048 }\r\n        its('algorithm') { should_not cmp 'rsasha1' }\r\n      end\r\n    end\r\n  end\r\nend\r\n","source_location":{"ref":"./controls/8_04.rb","line":3},"id":"8_04_dnssec_enabled"}],"groups":[{"title":null,"controls":["2_01_key_rotation","2_01_overly_permissive_service_account_privileges","2_01_iam_user_with_service_account_privileges"],"id":"controls/2_01.rb"},{"title":null,"controls":["2_02_non_corporate_accounts"],"id":"controls/2_02.rb"},{"title":null,"controls":["2_03_mfa_enforced"],"id":"controls/3_01-and-2_03.rb"},{"title":null,"controls":["3_02_and_3_03_audit_log_enabled"],"id":"controls/3_02-and-3_03.rb"},{"title":null,"controls":["3_06_iam_user_with_overly_permissive_kms_roles","3_06_secure_kms_usage"],"id":"controls/3_06.rb"},{"title":null,"controls":["4_05_compute_instance_block_ssh_keys"],"id":"controls/4_05.rb"},{"title":null,"controls":["5_01_public_buckets_all_users_restricted","5_01_public_buckets_all_authenticated_users_restricted","5_01_buckets_uniform_access_enforced"],"id":"controls/5_01.rb"},{"title":null,"controls":["5_04_enable_storage_log_bucket_object_versioning"],"id":"controls/5_04.rb"},{"title":null,"controls":["6_01_01_db_ports"],"id":"controls/6_01_01.rb"},{"title":null,"controls":["6_01_02_admin_ports"],"id":"controls/6_01_02.rb"},{"title":null,"controls":["6_01_03_infra_ports"],"id":"controls/6_01_03.rb"},{"title":null,"controls":["6_01_04_fileshare_ports"],"id":"controls/6_01_04.rb"},{"title":null,"controls":["6_01_05_telnet_ports"],"id":"controls/6_01_05.rb"},{"title":"Enforce SSL policy having TLS version of at least v1.2 (TLS v1. 1, 1.0 and SSLv3 are forbidden) for LoadBalancer","controls":["6_03_secure_load_balancer_configuration"],"id":"controls/6_03.rb"},{"title":null,"controls":["6_04_gcp_vpn_secure_configuration"],"id":"controls/6_04.rb"},{"title":null,"controls":["7_04_gke_master_authorized_networks","7_04_gke_unsupported_master_version","7_04_gke_unsupported_node_version"],"id":"controls/7_04.rb"},{"title":null,"controls":["7_06_gke_stackdriver_monitoring_enabled","7_06_gke_legacy_authorization_enabled"],"id":"controls/7_06.rb"},{"title":null,"controls":["7_11_disable_gke_basic_authentication"],"id":"controls/7_11.rb"},{"title":null,"controls":["7_12_enable_gke_cluster_private_nodes"],"id":"controls/7_12.rb"},{"title":null,"controls":["7_15_gke_container_optimized_node_image"],"id":"controls/7_15.rb"},{"title":null,"controls":["8_01_caching_encryption_and_versioning","8_01_caching_network_and_availability"],"id":"controls/8_01.rb"},{"title":null,"controls":["8_03_sql_instance_configure_ssl","8_03_sql_instance_network_authorization"],"id":"controls/8_03.rb"},{"title":null,"controls":["8_04_dnssec_enabled"],"id":"controls/8_04.rb"}],"sha256":"b42688758e96088042c30c5e2d88dafe52a2ff10535315f0b863d28d9e2fafa3","status_message":"","status":"loaded","generator":{"name":"inspec","version":"4.56.17"}}
